<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain Hacker Record</title>
    <style>
        body {
            margin: 0;
            padding: 15px; /* index.htmlと統一 */
            font-family: sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            /* record.htmlのRecordの文字を、Home側の日付表示と同じスタイルに変更 */
            font-size: 1.2em; 
            font-weight: bold;
            margin: 0; /* h1のデフォルトマージンをリセット */
        }

        .back-btn {
            padding: 8px 15px;
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .back-btn:hover {
            background-color: #3367d6;
        }

        .record-section {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px; /* index.htmlのcontrols, grid-containerと統一 */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); /* index.htmlのcontrols, grid-containerと統一 */
        }

        .record-section h2 {
            color: #4285f4;
            margin-top: 0;
            font-size: 1.4em;
            margin-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .summary-item {
            background-color: #e8f0fe; /* 薄い青色 */
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .summary-item h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.05em;
            color: #333;
        }

        .percentage-value {
            font-size: 2.2em;
            font-weight: bold;
            color: #4285f4;
            margin-bottom: 5px;
        }

        .task-counts {
            font-size: 0.9em;
            color: #555;
        }

        .summary-item.no-data {
            background-color: #f1f1f1;
            color: #888;
        }

        .streak-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .streak-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background-color: #e8f0fe;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .streak-item p {
            margin: 0;
            font-weight: bold;
            font-size: 0.9em;
            color: #4285f4;
        }

        .streak-item small {
            font-size: 0.85em;
            color: #555;
            margin-top: 2px;
        }

        .history-list {
            list-style: none;
            padding: 0;
        }

        .history-item {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .history-item:hover {
            background-color: #eef;
        }

        .history-item.no-record {
            text-align: center;
            color: #888;
            padding: 20px;
            background-color: #f1f1f1;
            cursor: default;
        }

        .history-date {
            font-weight: bold;
            font-size: 1.05em;
            color: #333;
        }

        .history-title {
            flex-grow: 1;
            margin-left: 15px;
            font-size: 0.95em;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.5); /* Black w/ opacity */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto; /* Adjust margin for more space */
            padding: 20px;
            border-radius: 5px;
            width: 90%; /* Wider for better content display */
            max-width: 800px; /* Max width for readability */
            height: 80%; /* Adjust height */
            overflow-y: auto; /* Enable scrolling for content */
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            position: relative; /* For close button positioning */
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: #333;
            text-decoration: none;
            cursor: pointer;
        }

        .history-grid-display {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(16, 1fr);
            width: 100%;
            height: auto; /* Adjust height based on content */
            min-height: 400px; /* Minimum height for visibility */
            gap: 1px;
            background-color: #eee;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 2px;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }

        .history-cell {
            border: 1px solid #eee;
            display: flex;
            flex-direction: column;
            /* セルコンテンツの配置をindex.htmlの.cellに合わせる */
            justify-content: flex-start; 
            align-items: flex-start;
            padding: 1px;
            font-size: 0.8vw; /* Smaller font size for history view */
            background-color: white;
            overflow: hidden; /* Hide overflow content */
            text-align: left;
            word-break: break-word;
            white-space: pre-wrap;
            box-sizing: border-box;
        }

        .history-cell img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
        }

        .history-cell .editable {
            all: unset; /* Reset all editable styles for static display */
            font-size: 1em; /* Relative to parent .history-cell's font size */
            padding: 2px;
            color: #333;
            overflow: hidden; /* Hide overflow for static display */
            text-overflow: ellipsis; /* Add ellipsis for overflowing text */
            display: -webkit-box;
            -webkit-line-clamp: 3; /* Limit to 3 lines */
            -webkit-box-orient: vertical;
            width: 100%; /* Take full width */
            box-sizing: border-box;
        }
        
        /* チェックボックスのスタイル */
        .checkbox-wrapper {
            display: flex;
            align-items: flex-start; /* チェックボックスとテキストを上揃え */
            margin-bottom: 2px; /* 各チェックボックス行の下マージンを狭める */
            line-height: 1.2; /* 行の高さを調整 */
        }

        .checkbox-text {
            flex-grow: 1; /* テキストが残りスペースを埋める */
            word-break: break-all; /* 長い単語でも折り返す */
            white-space: pre-wrap; /* 改行を保持 */
            margin-left: 3px; /* チェックボックスとの間隔 */
        }

        .checkbox-text.checked-item {
            text-decoration: line-through;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Record</h1>
            <a href="index.html" class="back-btn">Home</a>
        </div>

        <div class="record-section">
            <h2>Summary</h2>
            <div class="summary-grid">
                <div class="summary-item">
                    <h3>Total Checkbox Tasks</h3>
                    <div class="percentage-value" id="totalTasks">0</div>
                    <div class="task-counts">Tasks</div>
                </div>
                <div class="summary-item">
                    <h3>Completed Checkbox Tasks</h3>
                    <div class="percentage-value" id="completedTasks">0</div>
                    <div class="task-counts">Tasks</div>
                </div>
                <div class="summary-item">
                    <h3>Completion Rate</h3>
                    <div class="percentage-value" id="completionRate">0%</div>
                    <div class="task-counts"></div>
                </div>
            </div>
        </div>

        <div class="record-section">
            <h2>Streak</h2>
            <div class="streak-container" id="streakContainer">
                <div class="streak-item">
                    <p>🔥</p>
                    <small>No streak data</small>
                </div>
            </div>
        </div>

        <div class="record-section">
            <h2>History</h2>
            <ul class="history-list" id="historyList">
                <li class="history-item no-record">No records available.</li>
            </ul>
        </div>
    </div>

    <div id="historyModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 id="modalDateTitle"></h2>
            <div class="history-grid-display" id="modalGridDisplay">
                </div>
        </div>
    </div>

    <script>
        const historyList = document.getElementById('historyList');
        const modal = document.getElementById('historyModal');
        const closeButton = document.querySelector('.close-button');
        const modalDateTitle = document.getElementById('modalDateTitle');
        const modalGridDisplay = document.getElementById('modalGridDisplay');

        // === Checkbox Listener attachment for Modal ===
        function attachCheckboxListenersToModal(containerElement) {
            if (!containerElement) return;
            containerElement.querySelectorAll("input[type='checkbox']").forEach(cb => {
                const textSpan = cb.nextElementSibling;
                if (textSpan) {
                    textSpan.classList.toggle('checked-item', cb.checked);
                }
            });
        }

        // === Load History and Display Summary ===
        document.addEventListener('DOMContentLoaded', () => {
            loadHistory();
            calculateSummary();
            updateStreak();
        });

        closeButton.addEventListener('click', () => {
            modal.style.display = 'none';
        });

        window.addEventListener('click', (event) => {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        });

        function loadHistory() {
            historyList.innerHTML = ''; // Clear existing list
            const historyKeys = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('brainhack-') && key !== 'brainhack-title') { // Exclude general title storage
                    historyKeys.push(key);
                }
            }

            if (historyKeys.length === 0) {
                historyList.innerHTML = '<li class="history-item no-record">No records available.</li>';
                return;
            }

            // Sort by date descending
            historyKeys.sort((a, b) => {
                const dateA = a.replace('brainhack-', '');
                const dateB = b.replace('brainhack-', '');
                return new Date(dateB) - new Date(dateA);
            });

            historyKeys.forEach(key => {
                const compressedData = localStorage.getItem(key);
                if (compressedData) {
                    try {
                        const decodedData = decodeURIComponent(atob(compressedData));
                        const data = JSON.parse(decodedData);
                        const listItem = document.createElement('li');
                        listItem.className = 'history-item';
                        listItem.dataset.date = data.date;

                        const dateSpan = document.createElement('span');
                        dateSpan.className = 'history-date';
                        dateSpan.textContent = data.date;
                        listItem.appendChild(dateSpan);

                        const titleSpan = document.createElement('span');
                        titleSpan.className = 'history-title';
                        titleSpan.textContent = data.title || 'No Title';
                        listItem.appendChild(titleSpan);

                        listItem.addEventListener('click', () => openHistoryModal(data));
                        historyList.appendChild(listItem);
                    } catch (e) {
                        console.error(`Error loading history for key ${key}:`, e);
                    }
                }
            });
        }

        function openHistoryModal(data) {
            modalDateTitle.textContent = data.date + ' - ' + (data.title || 'No Title');
            modalGridDisplay.innerHTML = ''; // Clear previous grid

            // Create 320 cells for the modal display
            for (let i = 0; i < 16 * 20; i++) {
                const cell = document.createElement('div');
                cell.className = 'history-cell';
                const editable = document.createElement('div');
                editable.className = 'editable';
                editable.setAttribute('contenteditable', 'false'); // Not editable in modal
                const img = document.createElement('img');
                img.style.display = 'none';
                cell.appendChild(editable);
                cell.appendChild(img);
                modalGridDisplay.appendChild(cell);
            }

            // Populate cells with historical data, respecting merged cells
            data.cells.forEach(cellData => {
                const targetCellIndex = parseInt(cellData.row) * 20 + parseInt(cellData.col);
                const targetCell = modalGridDisplay.children[targetCellIndex];

                if (targetCell) {
                    const editable = targetCell.querySelector('.editable');
                    const img = targetCell.querySelector('img');

                    targetCell.style.backgroundColor = cellData.bgColor || '';
                    
                    if (cellData.gridRow || cellData.gridColumn) {
                        targetCell.style.gridRow = cellData.gridRow;
                        targetCell.style.gridColumn = cellData.gridColumn;
                        targetCell.style.display = cellData.display;
                    } else {
                        targetCell.style.gridRow = '';
                        targetCell.style.gridColumn = '';
                        targetCell.style.display = 'flex'; // Default display
                    }

                    if (cellData.imgSrc && cellData.imgSrc.startsWith("data:image/")) {
                        img.src = cellData.imgSrc;
                        img.style.display = 'block';
                        editable.innerHTML = ''; // Clear text if image is present
                    } else {
                        img.src = '';
                        img.style.display = 'none';
                        editable.innerHTML = cellData.html || '';
                        editable.style.fontSize = cellData.fontSize || '';
                        editable.style.alignItems = cellData.alignItems || '';
                        editable.style.justifyContent = cellData.justifyContent || '';
                        editable.style.textAlign = cellData.textAlign || '';
                    }

                    // Attach checkbox listeners for proper display in modal
                    attachCheckboxListenersToModal(editable);
                }
            });

            modal.style.display = 'flex'; // Show the modal
        }

        function calculateSummary() {
            let totalCheckboxTasks = 0;
            let completedCheckboxTasks = 0;
            let currentDayKey = getTodayKey();

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('brainhack-') && key !== 'brainhack-title' && key !== currentDayKey) {
                    const compressedData = localStorage.getItem(key);
                    if (compressedData) {
                        try {
                            const data = JSON.parse(decodeURIComponent(atob(compressedData)));
                            data.cells.forEach(cellData => {
                                // Create a temporary div to parse HTML content
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = cellData.html;
                                
                                // Find all checkboxes and their associated text spans
                                tempDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                                    totalCheckboxTasks++;
                                    if (checkbox.hasAttribute('checked') && checkbox.checked) {
                                        completedCheckboxTasks++;
                                    }
                                });
                            });
                        } catch (e) {
                            console.error(`Error parsing data for summary from key ${key}:`, e);
                        }
                    }
                }
            }

            document.getElementById('totalTasks').textContent = totalCheckboxTasks;
            document.getElementById('completedTasks').textContent = completedCheckboxTasks;

            if (totalCheckboxTasks > 0) {
                const completionRate = ((completedCheckboxTasks / totalCheckboxTasks) * 100).toFixed(1);
                document.getElementById('completionRate').textContent = `${completionRate}%`;
            } else {
                document.getElementById('completionRate').textContent = '0%';
                document.getElementById('completionRate').parentElement.classList.add('no-data');
            }
        }

        function updateStreak() {
            const streakContainer = document.getElementById('streakContainer');
            streakContainer.innerHTML = ''; // Clear existing content

            const today = new Date();
            const datesWithCompletedTasks = new Set();

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('brainhack-') && key !== 'brainhack-title') {
                    const compressedData = localStorage.getItem(key);
                    if (compressedData) {
                        try {
                            const data = JSON.parse(decodeURIComponent(atob(compressedData)));
                            let dayCompletedTasks = 0;
                            let dayTotalTasks = 0;

                            data.cells.forEach(cellData => {
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = cellData.html;
                                tempDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                                    dayTotalTasks++;
                                    if (checkbox.hasAttribute('checked') && checkbox.checked) {
                                        dayCompletedTasks++;
                                    }
                                });
                            });

                            if (dayTotalTasks > 0 && dayCompletedTasks === dayTotalTasks) {
                                datesWithCompletedTasks.add(data.date);
                            }
                        } catch (e) {
                            console.error(`Error processing streak data for key ${key}:`, e);
                        }
                    }
                }
            }

            let currentStreak = 0;
            let maxStreak = 0;
            let tempStreak = 0;
            
            // Check for current day's streak
            const todayDataKey = `brainhack-${getTodayKey()}`;
            const compressedTodayData = localStorage.getItem(todayDataKey);
            let todayCompletedAll = false;
            if (compressedTodayData) {
                try {
                    const todayData = JSON.parse(decodeURIComponent(atob(compressedTodayData)));
                    let todayTotal = 0;
                    let todayDone = 0;
                    todayData.cells.forEach(cellData => {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = cellData.html;
                        tempDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                            todayTotal++;
                            if (checkbox.hasAttribute('checked') && checkbox.checked) {
                                todayDone++;
                            }
                        });
                    });
                    if (todayTotal > 0 && todayDone === todayTotal) {
                        todayCompletedAll = true;
                    }
                } catch (e) {
                    console.error("Error processing today's data for streak:", e);
                }
            }


            for (let i = 0; i < 365; i++) { // Check for the last year
                const date = new Date(today);
                date.setDate(today.getDate() - i);
                const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

                let isCompleted = false;
                if (i === 0) { // If it's today
                    isCompleted = todayCompletedAll;
                } else {
                    isCompleted = datesWithCompletedTasks.has(dateKey);
                }
                
                if (isCompleted) {
                    tempStreak++;
                    maxStreak = Math.max(maxStreak, tempStreak);
                    if (i === 0 || datesWithCompletedTasks.has(getFormattedDate(new Date(date.setDate(date.getDate() + 1))))) {
                       currentStreak++;
                    } else if (i > 0 && !datesWithCompletedTasks.has(getFormattedDate(new Date(date.setDate(date.getDate() + 1))))) {
                        // If there's a gap before today, reset current streak only if today is also not completed.
                        // If today is completed, but yesterday wasn't, current streak is 1.
                        // This logic is tricky. Let's simplify and just count backwards from today.
                    }
                } else {
                    tempStreak = 0; // Reset consecutive days for max streak
                    if (i === 0 && !todayCompletedAll) {
                        currentStreak = 0; // If today is not completed, current streak is 0
                    } else if (i > 0) {
                        // If we encounter a non-completed day, and it's not today, the current streak must have ended before this day.
                        // So, if currentStreak was > 0, it means it started from an earlier completed day.
                        // We need to stop counting current streak once a non-completed day is met in reverse order.
                        // The `currentStreak` should only count back from today *consecutively*.
                    }
                }
            }

            // Recalculate current streak more robustly: count consecutive days backwards from today.
            currentStreak = 0;
            for (let i = 0; i <= 365; i++) { // Check for today and up to 365 days ago
                const date = new Date(today);
                date.setDate(today.getDate() - i);
                const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                
                let isCompletedForStreak = false;
                if (i === 0) { // For today
                    isCompletedForStreak = todayCompletedAll;
                } else { // For past days
                    isCompletedForStreak = datesWithCompletedTasks.has(dateKey);
                }

                if (isCompletedForStreak) {
                    currentStreak++;
                } else {
                    break; // Streak broken
                }
            }


            const currentStreakItem = document.createElement('div');
            currentStreakItem.className = 'streak-item';
            currentStreakItem.innerHTML = `<p>🔥 Current</p><small>${currentStreak} days</small>`;
            streakContainer.appendChild(currentStreakItem);

            const maxStreakItem = document.createElement('div');
            maxStreakItem.className = 'streak-item';
            maxStreakItem.innerHTML = `<p>🚀 Max</p><small>${maxStreak} days</small>`;
            streakContainer.appendChild(maxStreakItem);

            if (currentStreak === 0 && maxStreak === 0) {
                streakContainer.innerHTML = '<div class="streak-item"><p>🔥</p><small>No streak data</small></div>';
            }
        }

        function getTodayKey() {
            const now = new Date();
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
        }
        
        function getFormattedDate(date) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }

    </script>
</body>
</html>