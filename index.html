<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brain Hacker</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .title-area {
      flex-grow: 1;
    }
    
    .nav-buttons {
      display: flex;
      gap: 10px;
    }
    
    .nav-btn {
      padding: 8px 15px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 5px;
      text-decoration: none;
      font-size: 14px;
      cursor: pointer;
    }
    
    .title-input {
      font-size: 2em;
      width: 100%;
      border: none;
      background-color: transparent;
      /* ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®æ–‡å­—è‰²ã‚’ã‚°ãƒ¬ãƒ¼ã« */
      color: #333; /* å…¥åŠ›æ™‚ã®æ–‡å­—è‰² */
      outline: none;
      text-align: center;
      margin: 10px 0;
    }
    
    .title-input::placeholder {
      color: #999; /* Brain Hacker Home ã®æ–‡å­—è‰²ã‚’ã‚°ãƒ¬ãƒ¼ã« */
    }
    
    #dateDisplay {
      font-weight: bold;
      font-size: 1.2em;
      margin-bottom: 10px;
      color: #333;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 15px;
      background-color: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    .color-btn {
      width: 24px;
      height: 24px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
    }
    
    button {
      padding: 6px 10px;
      font-size: 14px;
      background-color: #f1f1f1;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      color: #333;
    }
    
    button:hover {
      background-color: #e9e9e9;
    }
    
    .size-btn {
      width: 32px;
      height: 32px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f1f1f1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .grid-container {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(16, 1fr);
      width: 100%;
      height: 75vh;
      gap: 1px;
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      padding: 2px;
    }
    
    .cell {
      border: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1px;
      font-size: 1vw;
      background-color: white;
      /* Ensure cells are always positioned based on their grid area */
      position: relative; /* Add relative positioning for consistent behavior */
    }
    
    .cell.selected {
      outline: 2px solid #4285f4;
    }
    
    .editable {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      flex-direction: column;
      font-size: 1vw;
      text-align: left;
      padding: 2px;
      border: none;
      outline: none;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .cell img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }
    
    /* Modal for sharing */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }
    
    .modal-content {
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border-radius: 5px;
      width: 80%;
      max-width: 500px;
    }
    
    .close-btn {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close-btn:hover {
      color: #333;
    }
    
    .share-input {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    .copy-btn {
      background-color: #4285f4;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      float: right;
    }
    /* History Modal specific styles */
    .history-modal-content {
      background-color: #fefefe;
      margin: 5% auto; /* Adjust margin for more space */
      padding: 20px;
      border-radius: 5px;
      width: 90%; /* Wider for better content display */
      max-width: 800px; /* Max width for readability */
      height: 80%; /* Adjust height */
      overflow-y: auto; /* Enable scrolling for content */
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .history-grid-display {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(16, 1fr);
      width: 100%;
      height: auto; /* Adjust height based on content */
      min-height: 400px; /* Minimum height for visibility */
      gap: 1px;
      background-color: #eee;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 2px;
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }

    .history-cell {
      border: 1px solid #eee;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1px;
      font-size: 0.8vw; /* Smaller font size for history view */
      background-color: white;
      overflow: hidden; /* Hide overflow content */
      text-align: left;
      word-break: break-word;
      white-space: pre-wrap;
    }

    .history-cell .editable {
        all: unset; /* Reset all editable styles for static display */
        font-size: 0.8vw; /* Keep consistent font size */
        padding: 2px;
        color: #333;
        overflow: hidden; /* Hide overflow for static display */
        text-overflow: ellipsis; /* Add ellipsis for overflowing text */
        display: -webkit-box;
        -webkit-line-clamp: 3; /* Limit to 3 lines */
        -webkit-box-orient: vertical;
    }
    .history-cell input[type='checkbox'] {
      margin-right: 3px;
    }

    /* ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®æ”¹è¡Œé–“éš”ã‚’ç‹­ã‚ã‚‹ãŸã‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .checkbox-wrapper {
      display: flex;
      align-items: flex-start; /* ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸Šæƒãˆ */
      margin-bottom: 2px; /* å„ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹è¡Œã®ä¸‹ãƒãƒ¼ã‚¸ãƒ³ã‚’ç‹­ã‚ã‚‹ */
      line-height: 1.2; /* è¡Œã®é«˜ã•ã‚’èª¿æ•´ */
    }
    /* editableå†…ã®brã‚¿ã‚°ãŒä¸è¦ã«ãªã‚‹ã‚ˆã†ã«ã€margin-bottomã§åˆ¶å¾¡ */
    .editable br {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title-area">
        <div id="dateDisplay"></div>
      </div>
      <div class="nav-buttons">
        <button id="shareBtn" class="nav-btn">Share</button>
        <a href="record.html" class="nav-btn">Record</a>
      </div>
    </div>
    
    <input class="title-input" id="pageTitle" placeholder="Brain Hacker Home" />
    
    <div class="controls">
      <button class="color-btn" data-color="#ffa500" style="background-color:#ffa500;"></button>
      <button class="color-btn" data-color="#f2c1c1" style="background-color:#f2c1c1;"></button>
      <button class="color-btn" data-color="#ffef5b" style="background-color:#ffef5b;"></button>
      <button class="color-btn" data-color="#d0f0c0" style="background-color:#d0f0c0;"></button>
      <button class="color-btn" data-color="#a2dff7" style="background-color:#a2dff7;"></button>
      <button class="color-btn" data-color="#d8d8d8" style="background-color:#d8d8d8;"></button>
      <button class="color-btn" data-color="#ffffff" style="background-color:#ffffff;"></button>
      <button id="mergeBtn">integrate</button>
      <button id="splitBtn">separate</button>
      <button id="insertCheckboxBtn">âœ… check</button>
      <button id="insertBoldCheckboxBtn">â˜‘ï¸ check</button>
      <button id="insertNoteBtn">ğŸ“ note</button> <button id="uploadImageBtn">ğŸ–¼ï¸</button>
      <input type="file" id="imageInput" accept="image/*" style="display: none;" />
      <button class="size-btn" data-size="2.56vw" style="font-size:2.56vw;">A</button>
      <button class="size-btn" data-size="1.92vw" style="font-size:1.92vw;">A</button>
      <button class="size-btn" data-size="1.6vw" style="font-size:1.6vw;">A</button>
      <button class="size-btn" data-size="1.28vw" style="font-size:1.28vw;">A</button>
      <button class="size-btn" data-size="0.8vw" style="font-size:0.8vw;">A</button>
      <button id="undoBtn">â†©ï¸</button> <button id="resetBtn">ğŸ”„</button>
      <button id="deleteBtn">ğŸ—‘ï¸</button>
      <button id="alignTopLeftBtn">left alignment</button>
      <button id="alignCenterBtn">centered</button>
    </div>
    
    <div class="grid-container" id="grid"></div>
  </div>

  <div id="shareModal" class="modal">
    <div class="modal-content">
      <span class="close-btn">&times;</span>
      <h2>Share Your Brain Hacker</h2>
      <p>Copy this link to share your Brain Hacker with others:</p>
      <input type="text" id="shareLink" class="share-input" readonly>
      <button id="copyBtn" class="copy-btn">Copy Link</button>
    </div>
  </div>

<script>
// === æ—¥ä»˜ã¨ã‚¿ã‚¤ãƒˆãƒ« ===
function getTodayKey() {
  const now = new Date();
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
}
function getYesterdayKey() {
  const now = new Date();
  now.setDate(now.getDate() - 1);
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
}
document.getElementById("dateDisplay").textContent = `${getTodayKey()} (${["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][new Date().getDay()]})`;

// === è‡ªå‹•ä¿å­˜ã®ãŸã‚ã®Debounceæ©Ÿèƒ½ ===
let autoSaveTimeout;
const AUTO_SAVE_DELAY = 1000; // 1ç§’ (1000ms)

function autoSave() {
  clearTimeout(autoSaveTimeout);
  autoSaveTimeout = setTimeout(() => {
    saveState();
    console.log("Grid state automatically saved.");
  }, AUTO_SAVE_DELAY);
}

// === çŠ¶æ…‹ä¿å­˜ã¨å¾©å…ƒï¼ˆUndoæ©Ÿèƒ½ã®ãŸã‚ã«å±¥æ­´ã‚’ç®¡ç†ï¼‰ ===
const undoHistory = [];
const MAX_HISTORY = 20; // ä¿å­˜ã™ã‚‹å±¥æ­´ã®æœ€å¤§æ•°

function saveState() {
  const state = [...document.querySelectorAll(".cell")].map(cell => {
    const editable = cell.querySelector(".editable");
    const img = cell.querySelector("img");
    editable.querySelectorAll("input[type='checkbox']").forEach(cb => {
      cb.checked ? cb.setAttribute("checked", "checked") : cb.removeAttribute("checked");
    });
    return {
      row: cell.dataset.row,
      col: cell.dataset.col,
      html: editable.innerHTML,
      fontSize: editable.style.fontSize,
      bgColor: cell.style.backgroundColor,
      display: cell.style.display,
      gridRow: cell.style.gridRow,
      gridColumn: cell.style.gridColumn,
      imgSrc: (img.src && img.src !== "undefined" && img.src !== "null" && img.style.display !== 'none') ? img.src : "",
      alignItems: editable.style.alignItems,
      justifyContent: editable.style.justifyContent,
      textAlign: editable.style.textAlign
    };
  });

  const fullState = {
    title: document.getElementById("pageTitle").value,
    date: getTodayKey(),
    cells: state
  };
  
  // Save to localStorage for daily persistence
  // encodeURIComponentã¨btoaã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’åœ§ç¸®ï¼ˆæ—¢å­˜ã®index.html.a.htmlã®å½¢å¼ï¼‰
  localStorage.setItem(`brainhack-${getTodayKey()}`, btoa(encodeURIComponent(JSON.stringify(fullState))));

  // Add to undo history
  undoHistory.push(JSON.parse(JSON.stringify(fullState))); // Deep copy
  if (undoHistory.length > MAX_HISTORY) {
    undoHistory.shift(); // Remove oldest state
  }
  console.log("State saved. History size:", undoHistory.length);
}

function restoreState(stateToRestore) {
  clearSelections(); // Clear selections before restoring

  let state;
  let isLoadedFromLocalStorage = false;

  // If restoring from localStorage (initial load or explicit restore)
  if (!stateToRestore) {
    const compressed = localStorage.getItem(`brainhack-${getTodayKey()}`);
    if (compressed) {
      try {
        state = JSON.parse(decodeURIComponent(atob(compressed))); // Decode and parse
        isLoadedFromLocalStorage = true;
      } catch (e) {
        console.error("Failed to load today's grid state from localStorage:", e);
        // Fallback to yesterday's state if today's is corrupted
      }
    }

    if (!state) { // Check for yesterday's state if today's is empty or corrupted
      const yCompressed = localStorage.getItem(`brainhack-${getYesterdayKey()}`);
      if (yCompressed) {
        try {
          const parsed = JSON.parse(decodeURIComponent(atob(yCompressed)));
          parsed.cells.forEach(c => {
            const temp = document.createElement("div");
            temp.innerHTML = c.html;
            
            // å¤ªå­—ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹é …ç›®ã‚’å‰Šé™¤ (å¤ªå­—ã¯æŒã¡è¶Šã•ãªã„)
            const filteredNodes = [...temp.childNodes].filter(node => {
              const cb = node.querySelector?.("input[type='checkbox']");
              const sp = node.querySelector?.("span");
              return !(cb && sp?.style.fontWeight === "bold");
            });
            
            // é€šå¸¸ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ãƒã‚§ãƒƒã‚¯ã¨å–ã‚Šæ¶ˆã—ç·šã‚’ãƒªã‚»ãƒƒãƒˆ
            filteredNodes.forEach(node => {
              const cb = node.querySelector?.("input[type='checkbox']");
              const sp = node.querySelector?.("span");
              if (cb && sp && !sp.style.fontWeight.includes("bold")) {
                cb.removeAttribute("checked");
                sp.style.textDecoration = "none";
              }
            });
            
            const wrapper = document.createElement("div");
            filteredNodes.forEach(n => wrapper.appendChild(n.cloneNode(true)));
            c.html = wrapper.innerHTML;
          });
          state = {
              title: parsed.title,
              date: getTodayKey(), // Set today's date for restored content
              cells: parsed.cells
          };
          // Save the restored yesterday's state as today's state
          localStorage.setItem(`brainhack-${getTodayKey()}`, btoa(encodeURIComponent(JSON.stringify(state))));
          isLoadedFromLocalStorage = true;
        } catch (e) {
            console.error("Failed to load yesterday's grid state from localStorage:", e);
        }
      }
    }
  } else {
      state = stateToRestore; // Use provided state for undo
  }

  if (!state) return;
  const parsedFullState = typeof state === 'string' ? JSON.parse(state) : state;
  const parsedCells = parsedFullState.cells;

  document.getElementById("pageTitle").value = parsedFullState.title || "Brain Hacker Home";

  // Reset all cells to default before applying state, crucial for merge/split fix
  document.querySelectorAll(".cell").forEach(cell => {
    cell.style.display = "flex";
    cell.style.gridRow = "";
    cell.style.gridColumn = "";
    cell.querySelector(".editable").innerHTML = "";
    cell.querySelector("img").src = "";
    cell.querySelector("img").style.display = "none";
    cell.style.backgroundColor = "";
    cell.querySelector(".editable").style.fontSize = "";
    cell.querySelector(".editable").style.alignItems = "";
    cell.querySelector(".editable").style.justifyContent = "";
    cell.querySelector(".editable").style.textAlign = "";
  });

  parsedCells.forEach(data => {
    const cell = document.querySelector(`.cell[data-row='${data.row}'][data-col='${data.col}']`);
    if (!cell) return; // Skip if cell doesn't exist (e.g., malformed data)

    const editable = cell.querySelector(".editable");
    const img = cell.querySelector("img");
    
    editable.innerHTML = typeof data.html === 'string' ? data.html : "";
    
    editable.style.fontSize = data.fontSize || "";
    editable.style.alignItems = data.alignItems || "";
    editable.style.justifyContent = data.justifyContent || "";
    editable.style.textAlign = data.textAlign || "";
    
    cell.style.backgroundColor = data.bgColor || "";
    cell.style.display = data.display || "flex"; // Default to flex if display is not set
    cell.style.gridRow = data.gridRow || "";
    cell.style.gridColumn = data.gridColumn || "";
    
    if (data.imgSrc && data.imgSrc.startsWith("data:image/")) {
      img.src = data.imgSrc;
      img.style.display = 'block';
    } else {
      img.src = "";
      img.style.display = 'none';
    }

    // Attach change listeners for checkboxes immediately after setting innerHTML
    editable.querySelectorAll("input[type='checkbox']").forEach(cb => {
      cb.checked = cb.hasAttribute("checked");
      const sp = cb.nextElementSibling;
      if (sp) sp.style.textDecoration = cb.checked ? "line-through" : "none";
      // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ã—ã€æ–°ã—ã„autoSaveã‚’å‘¼ã³å‡ºã™ãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
      cb.removeEventListener("change", saveState); // æ—¢å­˜ã®saveStateã‚’å‰Šé™¤
      cb.addEventListener("change", autoSave); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
    });
  });
  console.log("State restored.");

  // æœ€åˆã®ãƒ­ãƒ¼ãƒ‰æ™‚ã«å±¥æ­´ã«è¿½åŠ 
  if (isLoadedFromLocalStorage && undoHistory.length === 0) {
      undoHistory.push(JSON.parse(JSON.stringify(parsedFullState)));
  }
}


// === ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ ===
const pageTitle = document.getElementById("pageTitle");
// pageTitleã®inputã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
pageTitle.removeEventListener("input", saveState); // æ—¢å­˜ã®saveStateã‚’å‰Šé™¤
pageTitle.addEventListener("input", () => {
    localStorage.setItem("pageTitle", document.getElementById("pageTitle").value);
    autoSave(); // Title change should also autoSave
});

const grid = document.getElementById("grid");
for (let row = 0; row < 16; row++) {
  for (let col = 0; col < 20; col++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.dataset.row = row;
    cell.dataset.col = col;
    const editable = document.createElement("div");
    editable.className = "editable";
    editable.contentEditable = true;
    // editableã®inputã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
    editable.removeEventListener('input', saveState); // æ—¢å­˜ã®saveStateã‚’å‰Šé™¤
    editable.addEventListener('input', autoSave); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
    const img = document.createElement("img");
    img.style.display = "none";
    cell.appendChild(editable);
    cell.appendChild(img);
    grid.appendChild(cell);
  }
}

// === ã‚»ãƒ«é¸æŠï¼ˆShiftãƒ‰ãƒ©ãƒƒã‚°å¯¾å¿œï¼‰ ===
let isDragging = false, dragStart = null;
const selectedCells = new Set();

// Function to clear all selections
function clearSelections() {
  selectedCells.clear();
  document.querySelectorAll(".cell").forEach(c => c.classList.remove("selected"));
}

grid.addEventListener("mousedown", e => {
  const cell = e.target.closest(".cell");
  if (!cell) return;
  const row = +cell.dataset.row, col = +cell.dataset.col;

  if (e.shiftKey) {
    isDragging = true;
    dragStart = { row, col };
  } else {
    clearSelections();
    cell.classList.add("selected");
    selectedCells.add(`${row},${col}`);
  }
});

grid.addEventListener("mousemove", e => {
  if (!isDragging || !e.shiftKey) return;
  const cell = e.target.closest(".cell");
  if (!cell) return;
  const endRow = +cell.dataset.row, endCol = +cell.dataset.col;

  const minRow = Math.min(dragStart.row, endRow);
  const maxRow = Math.max(dragStart.row, endRow);
  const minCol = Math.min(dragStart.col, endCol);
  const maxCol = Math.max(dragStart.col, endCol);

  clearSelections(); // Clear previous selections for continuous drag

  for (let r = minRow; r <= maxRow; r++) {
    for (let c = minCol; c <= maxCol; c++) {
      const target = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (target) {
        target.classList.add("selected");
        selectedCells.add(`${r},${c}`);
      }
    }
  }
});

window.addEventListener("mouseup", () => {
  isDragging = false;
});


// Undo Functionality
document.getElementById("undoBtn").addEventListener("click", () => {
  if (undoHistory.length > 1) { // Keep at least the current state (or a default empty state)
    undoHistory.pop(); // Remove current state
    const previousState = undoHistory[undoHistory.length - 1];
    restoreState(previousState);
  } else {
    alert("ã“ã‚Œä»¥ä¸Šæˆ»ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚");
  }
});


restoreState();
// window.addEventListener("beforeunload", saveState); // autoSaveãŒdebounceã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€beforeunloadã§ã®ç›´æ¥ã®saveStateã¯ä¸è¦

// === è‰²å¤‰æ›´æ©Ÿèƒ½ ===
for (const btn of document.querySelectorAll(".color-btn")) {
  btn.addEventListener("click", () => {
    const color = btn.dataset.color;
    for (const key of selectedCells) {
      const [r, c] = key.split(',');
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell) cell.style.backgroundColor = color;
    }
    autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
  });
}

// === ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ ===
document.getElementById("uploadImageBtn").addEventListener("click", () => {
  if (selectedCells.size !== 1) return alert("ç”»åƒã¯1ã‚»ãƒ«ã®ã¿ã«æ·»ä»˜å¯èƒ½ã§ã™");
  document.getElementById("imageInput").click();
});

document.getElementById("imageInput").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const [r, c] = [...selectedCells][0].split(',');
    const img = document.querySelector(`.cell[data-row='${r}'][data-col='${c}'] img`);
    const editable = document.querySelector(`.cell[data-row='${r}'][data-col='${c}'] .editable`);
    
    // Clear editable content if an image is being added
    editable.innerHTML = ''; 

    img.src = ev.target.result;
    img.style.display = "block";
    autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
  };
  reader.readAsDataURL(file);
});

// === ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹è¿½åŠ ï¼ˆæ™®é€šï¼‰ ===
document.getElementById("insertCheckboxBtn").addEventListener("click", () => {
  for (const key of selectedCells) {
    const [r, c] = key.split(',');
    const editable = document.querySelector(`.cell[data-row='${r}'][data-col='${c}'] .editable`);
    // æ–°ã—ã„ãƒ©ãƒƒãƒ‘ãƒ¼è¦ç´ ã‚’è¿½åŠ ã—ã€æ”¹è¡Œã‚’CSSã§åˆ¶å¾¡
    const wrapper = document.createElement("span");
    wrapper.classList.add("checkbox-wrapper"); /* æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ  */
    // wrapper.style.display = "inline-flex"; // checkbox-wrapperã‚¯ãƒ©ã‚¹ã§åˆ¶å¾¡
    // wrapper.style.alignItems = "center"; // checkbox-wrapperã‚¯ãƒ©ã‚¹ã§åˆ¶å¾¡
    const cb = document.createElement("input");
    cb.type = "checkbox";
    const span = document.createElement("span");
    span.textContent = "task"; /* ã€Œé …ç›®ã€ã‚’ã€Œtaskã€ã«å¤‰æ›´ */
    span.contentEditable = true;
    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®changeã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
    cb.addEventListener("change", () => {
      span.style.textDecoration = cb.checked ? "line-through" : "none";
      autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
    });
    wrapper.append(cb, span);
    editable.appendChild(wrapper);
    // editable.appendChild(document.createElement("br")); // brã‚¿ã‚°ã‚’å‰Šé™¤
  }
  autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
});

// === ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹è¿½åŠ ï¼ˆå¤ªå­—ï¼‰ ===
document.getElementById("insertBoldCheckboxBtn").addEventListener("click", () => {
  for (const key of selectedCells) {
    const [r, c] = key.split(',');
    const editable = document.querySelector(`.cell[data-row='${r}'][data-col='${c}'] .editable`);
    // æ–°ã—ã„ãƒ©ãƒƒãƒ‘ãƒ¼è¦ç´ ã‚’è¿½åŠ ã—ã€æ”¹è¡Œã‚’CSSã§åˆ¶å¾¡
    const wrapper = document.createElement("span");
    wrapper.classList.add("checkbox-wrapper"); /* æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ  */
    // wrapper.style.display = "inline-flex"; // checkbox-wrapperã‚¯ãƒ©ã‚¹ã§åˆ¶å¾¡
    // wrapper.style.alignItems = "center"; // checkbox-wrapperã‚¯ãƒ©ã‚¹ã§åˆ¶å¾¡
    const cb = document.createElement("input");
    cb.type = "checkbox";
    const span = document.createElement("span");
    span.textContent = "task"; /* ã€Œé …ç›®ã€ã‚’ã€Œtaskã€ã«å¤‰æ›´ */
    span.contentEditable = true;
    span.style.fontWeight = "bold";
    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®changeã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
    cb.addEventListener("change", () => {
      span.style.textDecoration = cb.checked ? "line-through" : "none";
      autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
    });
    wrapper.append(cb, span);
    editable.appendChild(wrapper);
    // editable.appendChild(document.createElement("br")); // brã‚¿ã‚°ã‚’å‰Šé™¤
  }
  autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
});

// === ãƒãƒ¼ãƒˆè¿½åŠ æ©Ÿèƒ½ ===
document.getElementById("insertNoteBtn").addEventListener("click", () => {
  if (selectedCells.size === 0) {
    alert("ãƒãƒ¼ãƒˆã‚’è¿½åŠ ã™ã‚‹ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    return;
  }
  for (const key of selectedCells) {
    const [r, c] = key.split(',');
    const editable = document.querySelector(`.cell[data-row='${r}'][data-col='${c}'] .editable`);
    
    // Create a div for the note to ensure it's on a new line and can be styled
    const noteDiv = document.createElement("div");
    noteDiv.contentEditable = true; // Make the note content editable
    noteDiv.innerHTML = "<b>Note:</b> "; // Bold "Note:"
    editable.appendChild(noteDiv);
    
    // Place cursor at the end of "Note: "
    const range = document.createRange();
    const sel = window.getSelection();
    range.setStart(noteDiv, noteDiv.childNodes.length);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
    
    editable.focus(); // Focus the editable div
  }
  autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
});


// === ã‚»ãƒ«çµåˆ ===
document.getElementById("mergeBtn").addEventListener("click", () => {
  if (selectedCells.size <= 1) {
    alert("çµåˆã™ã‚‹ã«ã¯è¤‡æ•°ã®ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  const coords = Array.from(selectedCells).map(k => k.split(',').map(Number));
  const rows = coords.map(c => c[0]);
  const cols = coords.map(c => c[1]);

  const minRow = Math.min(...rows);
  const maxRow = Math.max(...rows);
  const minCol = Math.min(...cols);
  const maxCol = Math.max(...cols);

  // Check if selected cells form a perfect rectangle
  const expectedSize = (maxRow - minRow + 1) * (maxCol - minCol + 1);
  if (selectedCells.size !== expectedSize) {
    alert("é€£ç¶šã™ã‚‹é•·æ–¹å½¢ã®ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  // Find the top-left cell which will become the merged cell
  const baseCell = document.querySelector(`.cell[data-row='${minRow}'][data-col='${minCol}']`);
  
  // Clear previous content from other cells and move it to the base cell
  let combinedHTML = '';
  const cellsToHide = [];

  for (let r = minRow; r <= maxRow; r++) {
    for (let c = minCol; c <= maxCol; c++) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell && (r !== minRow || c !== minCol)) { // If not the base cell
        combinedHTML += cell.querySelector(".editable").innerHTML;
        cell.querySelector(".editable").innerHTML = ''; // Clear content
        const img = cell.querySelector("img");
        if (img && img.src && img.style.display !== 'none') {
            // If there's an image in a non-base cell, move its src to base and hide it
            if (!baseCell.querySelector("img").src) { // Only if base doesn't have an image
                baseCell.querySelector("img").src = img.src;
                baseCell.querySelector("img").style.display = 'block';
            }
            img.src = '';
            img.style.display = 'none';
        }
        cellsToHide.push(cell);
      }
    }
  }

  // Append combined content to the base cell
  baseCell.querySelector(".editable").innerHTML += combinedHTML;

  // Apply grid span to the base cell
  baseCell.style.gridRow = `${minRow + 1} / span ${maxRow - minRow + 1}`;
  baseCell.style.gridColumn = `${minCol + 1} / span ${maxCol - minCol + 1}`;

  // Hide the other cells
  cellsToHide.forEach(cell => {
    cell.style.display = "none";
  });

  autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
});

// === ã‚»ãƒ«åˆ†é›¢ ===
document.getElementById("splitBtn").addEventListener("click", () => {
  if (selectedCells.size !== 1) {
    alert("åˆ†é›¢ã™ã‚‹ã«ã¯1ã¤ã®çµåˆã•ã‚ŒãŸã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    return;
  }
  const [r, c] = [...selectedCells][0].split(',').map(Number);
  const baseCell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);

  // Check if the cell is actually merged
  const rowSpan = parseInt(baseCell.style.gridRow?.split("span ")[1]) || 1;
  const colSpan = parseInt(baseCell.style.gridColumn?.split("span ")[1]) || 1;

  if (rowSpan === 1 && colSpan === 1) {
    alert("é¸æŠã•ã‚ŒãŸã‚»ãƒ«ã¯çµåˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
    return;
  }

  // Get current content and image from the base cell
  const baseContent = baseCell.querySelector(".editable").innerHTML;
  const baseImgSrc = baseCell.querySelector("img").src;

  // Clear content from the base cell after retrieving
  baseCell.querySelector(".editable").innerHTML = '';
  baseCell.querySelector("img").src = '';
  baseCell.querySelector("img").style.display = 'none';

  // Reset grid span for the base cell
  baseCell.style.gridRow = "";
  baseCell.style.gridColumn = "";
  baseCell.style.display = "flex"; // Ensure the base cell is visible

  // Distribute content (simple distribution: only to the base cell for now,
  // as more complex distribution would require user input)
  // For now, content stays in the top-left cell. If specific distribution is needed,
  // we'd need a more advanced UI or logic.
  baseCell.querySelector(".editable").innerHTML = baseContent;
  if (baseImgSrc && baseImgSrc.startsWith("data:image/")) {
      baseCell.querySelector("img").src = baseImgSrc;
      baseCell.querySelector("img").style.display = 'block';
  }


  // Show all cells within the original merged area
  for (let i = r; i < r + rowSpan; i++) {
    for (let j = c; j < c + colSpan; j++) {
      const cell = document.querySelector(`.cell[data-row='${i}'][data-col='${j}']`);
      if (cell) {
        cell.style.display = "flex";
      }
    }
  }
  autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
});


// === æ•´åˆ—ï¼ˆä¸­å¤® / å·¦ï¼‰ ===
document.getElementById("alignCenterBtn").addEventListener("click", () => {
  for (const key of selectedCells) {
    const [r, c] = key.split(',');
    const editable = document.querySelector(`.cell[data-row='${r}'][data-col='${c}'] .editable`);
    editable.style.alignItems = "center";
    editable.style.justifyContent = "center";
    editable.style.textAlign = "center";
  }
  autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
});
document.getElementById("alignTopLeftBtn").addEventListener("click", () => {
  for (const key of selectedCells) {
    const [r, c] = key.split(',');
    const editable = document.querySelector(`.cell[data-row='${r}'][data-col='${c}'] .editable`);
    editable.style.alignItems = "flex-start";
    editable.style.justifyContent = "flex-start";
    editable.style.textAlign = "left";
  }
  autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
});

// === å‰Šé™¤ãƒœã‚¿ãƒ³ ===
document.getElementById("deleteBtn").addEventListener("click", () => {
  for (const key of selectedCells) {
    const [r, c] = key.split(',');
    const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
    cell.querySelector(".editable").innerHTML = "";
    const img = cell.querySelector("img");
    img.src = "";
    img.style.display = "none";
  }
  autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
});

// === ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºå¤‰æ›´ ===
for (const btn of document.querySelectorAll(".size-btn")) {
  btn.addEventListener("click", () => {
    const size = btn.dataset.size;
    for (const key of selectedCells) {
      const [r, c] = key.split(',');
      const editable = document.querySelector(`.cell[data-row='${r}'][data-col='${c}'] .editable`);
      editable.style.fontSize = size;
    }
    autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
  });
}

// === ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ ===
document.getElementById("resetBtn").addEventListener("click", () => {
  if (confirm("å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) {
    // å„ã‚»ãƒ«ã®å†…å®¹ã€ç”»åƒã€ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ã‚¯ãƒªã‚¢
    document.querySelectorAll(".cell").forEach(cell => {
      const editable = cell.querySelector(".editable");
      const img = cell.querySelector("img");
      editable.innerHTML = "";
      editable.style.fontSize = "";
      editable.style.alignItems = "";
      editable.style.justifyContent = "";
      editable.style.textAlign = "";
      cell.style.backgroundColor = "";
      cell.style.display = "flex";
      cell.style.gridRow = "";
      cell.style.gridColumn = "";
      img.src = "";
      img.style.display = "none";
    });
    autoSave(); // autoSaveã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
    localStorage.removeItem(`brainhack-${getTodayKey()}`);
    // ã‚¿ã‚¤ãƒˆãƒ«ã¯å‰Šé™¤ã—ãªã„
    location.reload();
  }
});
// ã‚·ã‚§ã‚¢ãƒ¢ãƒ¼ãƒ€ãƒ«é–¢é€£ã®å‡¦ç†
const shareBtn = document.getElementById("shareBtn");
const shareModal = document.getElementById("shareModal");
const shareLink = document.getElementById("shareLink");
const copyBtn = document.getElementById("copyBtn");
const closeBtn = document.querySelector(".close-btn");

// ã‚·ã‚§ã‚¢ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã®å‡¦ç†
shareBtn.addEventListener("click", () => {
    const fullState = {
        title: document.getElementById("pageTitle").value,
        date: getTodayKey(),
        cells: [...document.querySelectorAll(".cell")].map(cell => {
            const editable = cell.querySelector(".editable");
            const img = cell.querySelector("img");
            editable.querySelectorAll("input[type='checkbox']").forEach(cb => {
                cb.checked ? cb.setAttribute("checked", "checked") : cb.removeAttribute("checked");
            });
            return {
                row: cell.dataset.row,
                col: cell.dataset.col,
                html: editable.innerHTML,
                fontSize: editable.style.fontSize,
                bgColor: cell.style.backgroundColor,
                display: cell.style.display,
                gridRow: cell.style.gridRow,
                gridColumn: cell.style.gridColumn,
                imgSrc: (img.src && img.src !== "undefined" && img.src !== "null" && img.style.display !== 'none') ? img.src : "",
                alignItems: editable.style.alignItems,
                justifyContent: editable.style.justifyContent,
                textAlign: editable.style.textAlign
            };
        })
    };

    const compressed = btoa(encodeURIComponent(JSON.stringify(fullState))); // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
    const shareURL = `${window.location.origin}/Brainhacker2.0/record.html?data=${compressed}`; // record.htmlã¸ã®ãƒ‘ã‚¹ã‚’ä¿®æ­£
    shareLink.value = shareURL;
    shareModal.style.display = "block";
});

// ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
closeBtn.addEventListener("click", () => {
  shareModal.style.display = "none";
});

// ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
window.addEventListener("click", (event) => {
  if (event.target == shareModal) {
    shareModal.style.display = "none";
  }
});

// ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
copyBtn.addEventListener("click", () => {
  shareLink.select();
  document.execCommand("copy");
  alert("ãƒªãƒ³ã‚¯ãŒã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸï¼");
});
</script>
</body>
</html>