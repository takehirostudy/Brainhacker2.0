<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brain Hacker</title>
  <style>
    body {
      margin: 0;
      padding: 10px 20px; /* Reduced top padding from 20px to 10px */
      font-family: sans-serif;
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px; /* Reduced margin-bottom from 20px to 10px */
    }
    
    .title-area {
      flex-grow: 1;
    }
    
    .nav-buttons {
      display: flex;
      gap: 10px;
    }
    
    .nav-btn {
      padding: 8px 15px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 5px;
      text-decoration: none;
      font-size: 14px;
      cursor: pointer;
    }
    
    .title-input {
      font-size: 2em;
      width: 100%;
      border: none;
      background-color: transparent;
      color: #333;
      outline: none;
      text-align: center;
      margin: 5px 0; /* Reduced top/bottom margin from 10px to 5px */
    }
    
    .title-input::placeholder {
      color: #999;
    }
    
    #dateDisplay {
      font-weight: bold;
      font-size: 1.2em;
      margin-bottom: 5px; /* Reduced margin-bottom from 10px to 5px */
      color: #333;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px; /* Reduced margin-bottom from 15px to 10px */
      background-color: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    button {
      padding: 6px 10px;
      font-size: 14px;
      background-color: #e8f0fe;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      color: #333;
    }
    
    button:hover {
      background-color: #e9e9e9;
    }

    .color-btn {
      width: 24px;
      height: 24px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
    }

    .border-color-btn { /* Added style for border color buttons */
      width: 24px;
      height: 24px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      background-color: white; /* Make background white to show border color clearly */
    }
    
    .size-btn {
      width: 32px;
      height: 32px;
      border: 1px solid #ddd;
      border-radius: 4pt;
      background-color: #e8f0fe;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .white-text-btn { /* Modified style for white text button */
        width: 32px;
        height: 32px;
        border: 1px solid #ddd; /* Same border as surrounding buttons */
        border-radius: 4px;
        background-color: #e8f0fe; /* Same background as surrounding buttons */
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white; /* White text */
        font-size: 1.6vw; /* Same size as middle 'A' */
        text-shadow: 0 0 2px black; /* Outline for white text on white/light background */
    }

    .black-text-btn { /* New style for black text button */
        width: 32px;
        height: 32px;
        border: 1px solid #ddd; /* Same border as surrounding buttons */
        border-radius: 4px;
        background-color: #e8f0fe; /* Same background as surrounding buttons */
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: black; /* Black text */
        font-size: 1.6vw; /* Same size as middle 'A' */
        text-shadow: 0 0 2px white; /* Outline for black text on light background */
    }
    
    .grid-container {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(16, 1fr);
      width: 100%;
      height: 75vh;
      gap: 1px;
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      padding: 2px;
    }
    
    .cell {
      border: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1px;
      font-size: 1vw;
      background-color: white;
      position: relative;
    }
    
    .cell.selected {
      outline: 2px solid #4285f4;
    }
    
    .editable {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      flex-direction: column;
      font-size: 1vw;
      text-align: left;
      padding: 2px;
      border: none;
      outline: none;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .cell img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }
    
    /* Modal for sharing */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: #fefefe;
      margin: auto;
      padding: 20px;
      border-radius: 5px;
      width: 80%;
      max-width: 500px;
    }
    
    .close-btn {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close-btn:hover {
      color: #333;
    }
    
    .share-input {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    
    .copy-btn {
      background-color: #4285f4;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      float: right;
    }
    /* History Modal specific styles */
    .history-modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 20px;
      border-radius: 5px;
      width: 90%;
      max-width: 800px;
      height: 80%;
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .history-grid-display {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(16, 1fr);
      width: 100%;
      height: auto;
      min-height: 400px;
      gap: 1px;
      background-color: #eee;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 2px;
      box-sizing: border-box;
    }

    .history-cell {
      border: 1px solid #eee;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1px;
      font-size: 0.8vw;
      background-color: white;
      overflow: hidden;
      text-align: left;
      word-break: break-word;
      white-space: pre-wrap;
    }

    .history-cell .editable {
        all: unset;
        font-size: 0.8vw;
        padding: 2px;
        color: #333;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
    }

    /* ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®æ”¹è¡Œé–“éš”ã‚’ç‹­ã‚ã‚‹ãŸã‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .checkbox-wrapper {
      display: flex;
      align-items: flex-start;
      margin-bottom: 2px;
      line-height: 1.2;
    }
    /* editableå†…ã®brã‚¿ã‚°ãŒä¸è¦ã«ãªã‚‹ã‚ˆã†ã«ã€margin-bottomã§åˆ¶å¾¡ */
    .editable br {
      display: none;
    }

    /* ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¨ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .checkbox-text {
      flex-grow: 1;
      word-break: break-all;
      white-space: pre-wrap;
      margin-left: 3px;
    }

    /* ãƒã‚§ãƒƒã‚¯ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .checkbox-text.checked-item {
      text-decoration: line-through;
      color: #888;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title-area">
        <div id="dateDisplay"></div>
      </div>
      <div class="nav-buttons">
        <a href="record.html" class="nav-btn">Record</a>
      </div>
    </div>
    
    <input class="title-input" id="pageTitle" placeholder="Brain Hacker Home" />
    
<div class="controls">
  <button class="color-btn" data-color="#3367d6" style="background-color:#3367d6;"></button>
  <button class="color-btn" data-color="#4285f4" style="background-color:#4285f4;"></button>
  <button class="color-btn" data-color="#e8f0fe" style="background-color:#e8f0fe;"></button>
  <button class="color-btn" data-color="#555555" style="background-color:#555555;"></button>
  <button class="color-btn" data-color="#e0e0e0" style="background-color:#e0e0e0;"></button>
  <button class="color-btn" data-color="#ffffff" style="background-color:#ffffff;"></button>
  <button class="border-color-btn" data-border-color="#3367d6" style="border-color:#3367d6;"></button>
  <button class="border-color-btn" data-border-color="#4285f4" style="border-color:#4285f4;"></button>
  <button class="border-color-btn" data-border-color="#555555" style="border-color:#555555;"></button>
  <button class="border-color-btn" id="resetBorderBtn" data-border-color="#ddd" style="border-color:#ddd;"></button> <button id="mergeBtn">integrate</button>
  <button id="splitBtn">separate</button>
  <button id="insertCheckboxBtn">âœ…</button>
  <button id="insertBoldCheckboxBtn">â˜‘ï¸</button>
  <button id="uploadImageBtn">ğŸ–¼ï¸</button>
  <input type="file" id="imageInput" accept="image/*" style="display: none;" />
  <button class="black-text-btn" data-text-color="black">A</button>
  <button class="white-text-btn" data-text-color="white">A</button>
  <button class="size-btn" data-size="2.56vw" style="font-size:2.56vw;">A</button>
  <button class="size-btn" data-size="1.92vw" style="font-size:1.92vw;">A</button>
  <button class="size-btn" data-size="1.6vw" style="font-size:1.6vw;">A</button>
  <button class="size-btn" data-size="1.0vw" style="font-size:1.0vw;">A</button>
  <button class="size-btn" data-size="0.6vw" style="font-size:0.6vw;">A</button>
  <button id="undoBtn">â†©ï¸</button> <button id="resetBtn">ğŸ”„</button>
  <button id="deleteBtn">ğŸ—‘ï¸</button>
  <button id="alignTopLeftBtn">left alignment</button>
  <button id="alignCenterBtn">centered</button>
</div>
    
    <div class="grid-container" id="grid"></div>
  </div>

<script>
// === æ—¥ä»˜ã¨ã‚¿ã‚¤ãƒˆãƒ« ===
function getTodayKey() {
  const now = new Date();
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
}
function getYesterdayKey() {
  const now = new Date();
  now.setDate(now.getDate() - 1);
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
}
document.getElementById("dateDisplay").textContent = `${getTodayKey()} (${["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][new Date().getDay()]})`;

// === è‡ªå‹•ä¿å­˜ã®ãŸã‚ã®Debounceæ©Ÿèƒ½ ===
let autoSaveTimeout;
const AUTO_SAVE_DELAY = 1000; // 1ç§’ (1000ms)

function autoSave() {
  clearTimeout(autoSaveTimeout);
  autoSaveTimeout = setTimeout(() => {
    saveState();
    console.log("Grid state automatically saved.");
  }, AUTO_SAVE_DELAY);
}

// === çŠ¶æ…‹ä¿å­˜ã¨å¾©å…ƒï¼ˆUndoæ©Ÿèƒ½ã®ãŸã‚ã«å±¥æ­´ã‚’ç®¡ç†ï¼‰ ===
const undoHistory = [];
const MAX_HISTORY = 20; // ä¿å­˜ã™ã‚‹å±¥æ­´ã®æœ€å¤§æ•°

// saveStateé–¢æ•°ã‚’ä¿®æ­£: undoHistoryã¸ã®è¿½åŠ ãƒ­ã‚¸ãƒƒã‚¯ã‚’ã‚ˆã‚Šåˆ¶å¾¡ã•ã‚ŒãŸã‚‚ã®ã«ã™ã‚‹
function saveState(addToHistory = true) { // addToHistoryå¼•æ•°ã‚’è¿½åŠ 
  const state = [...document.querySelectorAll(".cell")].map(cell => {
    const editable = cell.querySelector(".editable");
    const img = cell.querySelector("img");
    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’HTMLã«åæ˜ ã•ã›ã‚‹ (é‡è¦)
    editable.querySelectorAll("input[type='checkbox']").forEach(cb => {
      cb.checked ? cb.setAttribute("checked", "checked") : cb.removeAttribute("checked");
      const textSpan = cb.nextElementSibling;
      if (textSpan) {
        textSpan.classList.toggle('checked-item', cb.checked);
      }
    });
    return {
      row: cell.dataset.row,
      col: cell.dataset.col,
      html: editable.innerHTML,
      fontSize: editable.style.fontSize,
      bgColor: cell.style.backgroundColor,
      display: cell.style.display,
      gridRow: cell.style.gridRow,
      gridColumn: cell.style.gridColumn,
      imgSrc: (img.src && img.src !== "undefined" && img.src !== "null" && img.style.display !== 'none') ? img.src : "",
      alignItems: editable.style.alignItems,
      justifyContent: editable.style.justifyContent,
      textAlign: editable.style.textAlign,
      borderColor: cell.style.borderColor,
      color: editable.style.color
    };
  });

  const fullState = {
    title: document.getElementById("pageTitle").value,
    date: getTodayKey(),
    cells: state
  };
  
  localStorage.setItem(`brainhack-${getTodayKey()}`, btoa(encodeURIComponent(JSON.stringify(fullState))));

  if (addToHistory) { // addToHistoryãŒtrueã®å ´åˆã®ã¿å±¥æ­´ã«è¿½åŠ 
    undoHistory.push(JSON.parse(JSON.stringify(fullState))); // Deep copy
    if (undoHistory.length > MAX_HISTORY) {
      undoHistory.shift(); // Remove oldest state
    }
    console.log("State saved and added to history. History size:", undoHistory.length);
  } else {
    console.log("State saved (not added to history).");
  }
}

// === ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¢ã‚¿ãƒƒãƒã™ã‚‹å…±é€šé–¢æ•° ===
function attachCheckboxListeners(containerElement) {
    containerElement.querySelectorAll("input[type='checkbox']").forEach(cb => {
        cb.removeEventListener("change", handleCheckboxChange); // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
        cb.addEventListener("change", handleCheckboxChange); // æ–°ã—ã„ãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 

        const textSpan = cb.nextElementSibling;
        if (textSpan) {
            textSpan.classList.toggle('checked-item', cb.checked);
        }
    });
}

function handleCheckboxChange(event) {
    const checkbox = event.target;
    const textSpan = checkbox.nextElementSibling;
    if (textSpan) {
        textSpan.classList.toggle('checked-item', checkbox.checked);
    }
    autoSave();
}


function restoreState(stateToRestore) {
  clearSelections();

  let state;
  let isLoadedFromLocalStorage = false; // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã«localStorageã‹ã‚‰èª­ã¿è¾¼ã‚“ã ã‹ã©ã†ã‹

  if (!stateToRestore) { // stateToRestoreãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆï¼ˆåˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ãªã©ï¼‰
    const compressed = localStorage.getItem(`brainhack-${getTodayKey()}`);
    if (compressed) {
      try {
        state = JSON.parse(decodeURIComponent(atob(compressed)));
        isLoadedFromLocalStorage = true;
      } catch (e) {
        console.error("Failed to load today's grid state from localStorage:", e);
      }
    }

    if (!state) { // ä»Šæ—¥ã®ãƒ‡ãƒ¼ã‚¿ãŒãªã„ã€ã¾ãŸã¯ç ´æã—ã¦ã„ã‚‹å ´åˆã€æ˜¨æ—¥ã®ãƒ‡ãƒ¼ã‚¿ã‚’è©¦ã™
      const yCompressed = localStorage.getItem(`brainhack-${getYesterdayKey()}`);
      if (yCompressed) {
        try {
          const parsed = JSON.parse(decodeURIComponent(atob(yCompressed)));
          parsed.cells.forEach(c => {
            const temp = document.createElement("div");
            temp.innerHTML = c.html;
            
            // å¤ªå­—ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹é …ç›®ã‚’å‰Šé™¤ (å¤ªå­—ã¯æŒã¡è¶Šã•ãªã„)
            const filteredNodes = [...temp.childNodes].filter(node => {
              const wrapper = node.classList?.contains('checkbox-wrapper') ? node : null;
              const cb = wrapper ? wrapper.querySelector("input[type='checkbox']") : null;
              const sp = cb ? cb.nextElementSibling : null;
              
              return !(cb && sp?.style.fontWeight === "bold");
            });
            
            // é€šå¸¸ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ãƒã‚§ãƒƒã‚¯ã¨å–ã‚Šæ¶ˆã—ç·šã‚’ãƒªã‚»ãƒƒãƒˆ
            filteredNodes.forEach(node => {
              const cb = node.querySelector?.("input[type='checkbox']");
              const sp = cb ? cb.nextElementSibling : null;
              if (cb && sp && !sp.style.fontWeight.includes("bold")) {
                cb.removeAttribute("checked");
                sp.classList.remove("checked-item"); 
              }
            });
            
            const wrapper = document.createElement("div");
            filteredNodes.forEach(n => wrapper.appendChild(n.cloneNode(true)));
            c.html = wrapper.innerHTML;
          });
          state = {
              title: parsed.title,
              date: getTodayKey(),
              cells: parsed.cells
          };
          // æ˜¨æ—¥ã®çŠ¶æ…‹ã‚’ä»Šæ—¥ã®ã‚‚ã®ã¨ã—ã¦ä¿å­˜
          localStorage.setItem(`brainhack-${getTodayKey()}`, btoa(encodeURIComponent(JSON.stringify(state))));
          isLoadedFromLocalStorage = true;
        } catch (e) {
            console.error("Failed to load yesterday's grid state from localStorage:", e);
        }
      }
    }
  } else { // stateToRestoreãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆï¼ˆUndoæ™‚ãªã©ï¼‰
      state = stateToRestore;
  }

  // å¾©å…ƒã™ã‚‹çŠ¶æ…‹ãŒãªã„å ´åˆã€åˆæœŸã®ç©ºã®çŠ¶æ…‹ã‚’ä½œæˆ
  if (!state) {
    state = {
        title: "Brain Hacker Home",
        date: getTodayKey(),
        cells: []
    };
    // ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆæ™‚ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ç©ºã‚»ãƒ«ãŒä½œæˆã•ã‚Œã‚‹ã®ã§ã€ã“ã“ã§ã¯cellsã¯ç©ºã®ã¾ã¾ã§OK
  }

  const parsedFullState = state;
  const parsedCells = parsedFullState.cells;

  document.getElementById("pageTitle").value = parsedFullState.title || "Brain Hacker Home";

  // ã™ã¹ã¦ã®ã‚»ãƒ«ã‚’ä¸€åº¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹
  // çµåˆã‚»ãƒ«ãŒæ­£ã—ãå¾©å…ƒã•ã‚Œã‚‹ãŸã‚ã«ã¯ã€ã¾ãšã™ã¹ã¦ã®ã‚»ãƒ«ãŒç‹¬ç«‹ã—ãŸçŠ¶æ…‹ã«æˆ»ã‚‹å¿…è¦ãŒã‚ã‚‹
  const allGridCells = {};
  for (let r = 0; r < 16; r++) {
    for (let c = 0; c < 20; c++) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell) {
        cell.style.display = "flex"; // åˆæœŸçŠ¶æ…‹ã¯ã™ã¹ã¦è¡¨ç¤º
        cell.style.gridRow = "";
        cell.style.gridColumn = "";
        cell.querySelector(".editable").innerHTML = "";
        cell.querySelector("img").src = "";
        cell.querySelector("img").style.display = "none";
        cell.style.backgroundColor = "";
        cell.querySelector(".editable").style.fontSize = "";
        cell.querySelector(".editable").style.alignItems = "";
        cell.querySelector(".editable").style.justifyContent = "";
        cell.querySelector(".editable").style.textAlign = "";
        cell.style.borderColor = "";
        cell.querySelector(".editable").style.color = "";
        allGridCells[`${r}-${c}`] = cell;
      }
    }
  }

  // å¾©å…ƒã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å„ã‚»ãƒ«ã«é©ç”¨
  parsedCells.forEach(data => {
    const cell = allGridCells[`${data.row}-${data.col}`];
    if (!cell) return;

    const editable = cell.querySelector(".editable");
    const img = cell.querySelector("img");
    
    editable.innerHTML = typeof data.html === 'string' ? data.html : "";
    
    editable.style.fontSize = data.fontSize || "";
    editable.style.alignItems = data.alignItems || "";
    editable.style.justifyContent = data.justifyContent || "";
    editable.style.textAlign = data.textAlign || "";
    editable.style.color = data.color || "";
    
    cell.style.backgroundColor = data.bgColor || "";
    cell.style.borderColor = data.borderColor || "";
    
    // gridRowã¨gridColumnãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿displayã‚’flexã«è¨­å®šã—ã€spanã‚’é©ç”¨ã™ã‚‹
    // ãã†ã§ãªã„å ´åˆã¯ã€å…ƒã®displayãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«å¾“ã†ï¼ˆdisplay: noneã®å¯èƒ½æ€§ã‚‚ã‚ã‚‹ï¼‰
    if (data.gridRow && data.gridColumn) {
        cell.style.display = "flex"; // çµåˆã‚»ãƒ«ã¯å¸¸ã«è¡¨ç¤º
        cell.style.gridRow = data.gridRow;
        cell.style.gridColumn = data.gridColumn;
    } else {
        cell.style.display = data.display || "flex"; // çµåˆã•ã‚Œã¦ã„ãªã„ã‚»ãƒ«ã¯ä¿å­˜ã•ã‚ŒãŸdisplayå€¤ã‚’ä½¿ç”¨
    }

    if (data.imgSrc && data.imgSrc.startsWith("data:image/")) {
      img.src = data.imgSrc;
      img.style.display = 'block';
    } else {
      img.src = "";
      img.style.display = 'none';
    }

    attachCheckboxListeners(editable); // å„ã‚»ãƒ«å†…ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã«ãƒªã‚¹ãƒŠãƒ¼ã‚’å†ã‚¢ã‚¿ãƒƒãƒ
    editable.removeEventListener("input", autoSave); // é‡è¤‡é˜²æ­¢
    editable.addEventListener("input", autoSave);
  });
  
  console.log("State restored.");

  // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã®ã¿ã€å¾©å…ƒã•ã‚ŒãŸçŠ¶æ…‹ã‚’undoHistoryã«è¿½åŠ 
  // restoreStateãŒundoã‹ã‚‰ã®å‘¼ã³å‡ºã—ã§ãªã„ã“ã¨ã‚’ç¢ºèª
  if (stateToRestore === undefined) { // stateToRestoreãŒæ˜ç¤ºçš„ã«æ¸¡ã•ã‚Œã¦ã„ãªã„å ´åˆ
      // ç¾åœ¨ã®DOMã®çŠ¶æ…‹ã‹ã‚‰saveStateã‚’å‘¼ã³å‡ºã—ã€undoHistoryã«è¿½åŠ 
      // saveState(false)ã§localStorageã«ã¯ä¿å­˜ã›ãšã€undoHistoryã«ã®ã¿è¿½åŠ 
      if (undoHistory.length === 0 || JSON.stringify(undoHistory[undoHistory.length - 1].cells) !== JSON.stringify(parsedFullState.cells)) {
         // undoHistoryãŒç©ºã®å ´åˆã€ã¾ãŸã¯æœ€æ–°ã®çŠ¶æ…‹ã¨ç•°ãªã‚‹å ´åˆã®ã¿è¿½åŠ 
        saveState(true); // ä»Šå›ã®saveStateã¯addToHistory=trueã§å‘¼ã³å‡ºã™
      }
  }
}

// === ã‚°ãƒªãƒƒãƒ‰ç”Ÿæˆ ===
const pageTitle = document.getElementById("pageTitle");
pageTitle.removeEventListener("input", pageTitleInputHandler);
pageTitle.addEventListener("input", pageTitleInputHandler);

function pageTitleInputHandler() {
    localStorage.setItem("pageTitle", document.getElementById("pageTitle").value);
    autoSave();
}


const grid = document.getElementById("grid");
for (let row = 0; row < 16; row++) {
  for (let col = 0; col < 20; col++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.dataset.row = row;
    cell.dataset.col = col;
    cell.setAttribute("tabindex", "0");
    
    const editable = document.createElement("div");
    editable.className = "editable";
    editable.setAttribute("contenteditable", "true");
    
    editable.addEventListener("input", autoSave); // inputã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’åˆæœŸã‚»ãƒ«ä½œæˆæ™‚ã«ã‚¢ã‚¿ãƒƒãƒ
    
    const img = document.createElement("img");
    img.style.display = "none";

    cell.appendChild(editable);
    cell.appendChild(img);
    grid.appendChild(cell);
  }
}


// --- ã‚»ãƒ«é¸æŠãƒ­ã‚¸ãƒƒã‚¯ ---
let selectedCells = [];
let isMouseDown = false;
let startCell = null;

grid.addEventListener("mousedown", (e) => {
  if (e.target.closest(".cell")) {
    isMouseDown = true;
    startCell = e.target.closest(".cell");
    clearSelections();
    // Only select the cell if it's currently visible
    if (startCell.style.display !== 'none') {
        toggleCellSelection(startCell);
    }
  }
});

grid.addEventListener("mouseover", (e) => {
  if (isMouseDown && e.target.closest(".cell")) {
    const currentCell = e.target.closest(".cell");
    // Only consider visible cells for selection range
    if (startCell && currentCell && currentCell.style.display !== 'none') {
      selectRange(startCell, currentCell);
    }
  }
});

grid.addEventListener("mouseup", () => {
  isMouseDown = false;
  startCell = null;
});

document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    clearSelections();
  }
});

function clearSelections() {
  selectedCells.forEach((cell) => cell.classList.remove("selected"));
  selectedCells = [];
}

function toggleCellSelection(cell) {
  if (!cell || cell.style.display === 'none') return; // Don't select hidden cells
  cell.classList.toggle("selected");
  if (cell.classList.contains("selected")) {
    selectedCells.push(cell);
  } else {
    selectedCells = selectedCells.filter((c) => c !== cell);
  }
}

function selectRange(start, end) {
  clearSelections();
  const startRow = parseInt(start.dataset.row);
  const startCol = parseInt(start.dataset.col);
  const endRow = parseInt(end.dataset.row);
  const endCol = parseInt(end.dataset.col);

  const minRow = Math.min(startRow, endRow);
  const maxRow = Math.max(startRow, endRow);
  const minCol = Math.min(startCol, endCol);
  const maxCol = Math.max(startCol, endCol);

  for (let r = minRow; r <= maxRow; r++) {
    for (let c = minCol; c <= maxCol; c++) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      // Only add to selection if the cell is visible
      if (cell && cell.style.display !== 'none') { 
        cell.classList.add("selected");
        selectedCells.push(cell);
      }
    }
  }
}

// --- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³æ©Ÿèƒ½ ---
document.querySelectorAll(".color-btn").forEach((button) => {
  button.addEventListener("click", () => {
    const color = button.dataset.color;
    selectedCells.forEach((cell) => {
      cell.style.backgroundColor = color;
    });
    autoSave();
  });
});

document.querySelectorAll(".border-color-btn").forEach((button) => { /* New event listener for border color */
  button.addEventListener("click", () => {
    const borderColor = button.dataset.borderColor;
    selectedCells.forEach((cell) => {
      cell.style.borderColor = borderColor;
    });
    autoSave();
  });
});

// è¿½åŠ ã•ã‚ŒãŸã€ŒDefault Borderã€ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
document.getElementById("resetBorderBtn").addEventListener("click", () => {
  selectedCells.forEach((cell) => {
    cell.style.borderColor = "#ddd"; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¢ƒç•Œç·šã®è‰²
  });
  autoSave();
});

document.querySelectorAll(".size-btn").forEach((button) => {
  button.addEventListener("click", () => {
    const fontSize = button.dataset.size;
    selectedCells.forEach((cell) => {
      const editable = cell.querySelector(".editable");
      editable.style.fontSize = fontSize;
    });
    autoSave();
  });
});

document.querySelector(".white-text-btn").addEventListener("click", () => { /* New event listener for white text */
    selectedCells.forEach((cell) => {
        const editable = cell.querySelector(".editable");
        editable.style.color = "white";
    });
    autoSave();
});

document.querySelector(".black-text-btn").addEventListener("click", () => { /* New event listener for black text */
    selectedCells.forEach((cell) => {
        const editable = cell.querySelector(".editable");
        editable.style.color = "black";
    });
    autoSave();
});


document.getElementById("mergeBtn").addEventListener("click", () => {
  if (selectedCells.length < 2) {
    alert("çµåˆã™ã‚‹ã«ã¯2ã¤ä»¥ä¸Šã®ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  let minRow = Infinity, maxRow = -Infinity, minCol = Infinity, maxCol = -Infinity;
  selectedCells.forEach(cell => {
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    minRow = Math.min(minRow, row);
    maxRow = Math.max(row, maxRow); // Corrected: maxRow should update with current cell's row
    minCol = Math.min(minCol, col);
    maxCol = Math.max(col, maxCol); // Corrected: maxCol should update with current cell's col
  });

  const rowSpan = maxRow - minRow + 1;
  const colSpan = maxCol - minCol + 1;

  // Check if selected cells form a contiguous rectangle and are all visible
  const expectedCells = [];
  for (let r = minRow; r <= maxRow; r++) {
      for (let c = minCol; c <= maxCol; c++) {
          const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
          // çµåˆå¯¾è±¡ã®ã‚»ãƒ«ãŒå…ƒã€…éè¡¨ç¤ºï¼ˆdisplay:noneï¼‰ã«ãªã£ã¦ã„ã‚‹å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã¨ã™ã‚‹
          if (cell && cell.style.display !== 'none') { 
              expectedCells.push(cell);
          } else if (cell && cell.style.display === 'none') {
              alert("æ—¢ã«çµåˆã•ã‚Œã¦ã„ã‚‹ï¼ˆéè¡¨ç¤ºã«ãªã£ã¦ã„ã‚‹ï¼‰ã‚»ãƒ«ã‚’å«ã‚ã¦é¸æŠã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚");
              clearSelections();
              return;
          }
      }
  }
  // é¸æŠã•ã‚ŒãŸã‚»ãƒ«ã®æ•°ã¨æœŸå¾…ã•ã‚Œã‚‹ã‚»ãƒ«ã®æ•°ãŒä¸€è‡´ã—ã€ã‹ã¤ã™ã¹ã¦ã®é¸æŠã‚»ãƒ«ãŒæœŸå¾…ã•ã‚Œã‚‹ã‚»ãƒ«ã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹
  // ã“ã‚Œã«ã‚ˆã‚Šã€é£›ã³é£›ã³ã®é¸æŠã‚„ã€æ—¢ã«çµåˆã•ã‚Œã¦ã„ã‚‹ã‚»ãƒ«ã®ä¸€éƒ¨ã‚’é¸æŠã™ã‚‹ã®ã‚’é˜²ã
  if (selectedCells.length !== expectedCells.length || !selectedCells.every(cell => expectedCells.includes(cell))) {
      alert("é¸æŠã•ã‚ŒãŸã‚»ãƒ«ã¯é€£ç¶šã—ãŸé•·æ–¹å½¢ã‚’å½¢æˆã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚");
      clearSelections();
      return;
  }


  const firstCell = document.querySelector(`.cell[data-row='${minRow}'][data-col='${minCol}']`);
  if (!firstCell) return;

  let combinedHtml = "";
  // Sort cells by row then column to ensure content order
  selectedCells.sort((a, b) => {
      const rowA = parseInt(a.dataset.row);
      const colA = parseInt(a.dataset.col);
      const rowB = parseInt(b.dataset.row);
      const colB = parseInt(b.dataset.col);
      if (rowA !== rowB) return rowA - rowB;
      return colA - colB;
  }).forEach(cell => {
      const editableContent = cell.querySelector(".editable").innerHTML.trim();
      if (editableContent && cell !== firstCell) { // Only append content from cells that are not the firstCell
          combinedHtml += editableContent + "<br>"; 
      }
      // Clear content of cells that will be hidden
      if (cell !== firstCell) {
          cell.querySelector(".editable").innerHTML = "";
          cell.querySelector("img").src = "";
          cell.querySelector("img").style.display = "none";
      }
  });

  const firstCellEditable = firstCell.querySelector(".editable");
  // Prepend combined content to first cell's existing content, or set if no existing content
  if (combinedHtml) {
      if (combinedHtml.endsWith('<br>')) {
          combinedHtml = combinedHtml.slice(0, -4);
      }
      firstCellEditable.innerHTML = combinedHtml + (firstCellEditable.innerHTML ? '<br>' + firstCellEditable.innerHTML : '');
  }

  // Apply grid styles to the first cell
  firstCell.style.gridRow = `${minRow + 1} / span ${rowSpan}`;
  firstCell.style.gridColumn = `${minCol + 1} / span ${colSpan}`;
  firstCell.style.display = "flex"; // çµåˆã•ã‚ŒãŸã‚»ãƒ«ã¯å¿…ãšè¡¨ç¤º

  // Hide other selected cells and ensure their grid properties are reset
  selectedCells.forEach(cell => {
    if (cell !== firstCell) {
      cell.style.display = "none"; // éè¡¨ç¤ºã«ã™ã‚‹
      cell.style.gridRow = ""; // é‡è¦: grid-row/columnã‚’ãƒªã‚»ãƒƒãƒˆ
      cell.style.gridColumn = ""; // é‡è¦: grid-row/columnã‚’ãƒªã‚»ãƒƒãƒˆ
    }
  });

  attachCheckboxListeners(firstCellEditable);
  
  clearSelections();
  autoSave();
});

document.getElementById("splitBtn").addEventListener("click", () => {
  if (selectedCells.length !== 1) {
    alert("åˆ†å‰²ã™ã‚‹ã«ã¯1ã¤ã®ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  const cellToSplit = selectedCells[0];
  const row = parseInt(cellToSplit.dataset.row);
  const col = parseInt(cellToSplit.dataset.col);

  // currentStyleã‹ã‚‰grid-row-end, grid-column-endã‚’è¨ˆç®—ã—ã¦spanã‚’å–å¾—
  const computedStyle = window.getComputedStyle(cellToSplit);
  const gridRowEnd = parseInt(computedStyle.gridRowEnd);
  const gridColumnEnd = parseInt(computedStyle.gridColumnEnd);
  
  const currentRowSpan = gridRowEnd - parseInt(cellToSplit.style.gridRowStart || (row + 1));
  const currentColSpan = gridColumnEnd - parseInt(cellToSplit.style.gridColumnStart || (col + 1));


  // Reset styles for the main cell
  cellToSplit.style.gridRow = "";
  cellToSplit.style.gridColumn = "";
  cellToSplit.style.display = "flex"; // Ensure it's visible after splitting

  // Show all cells covered by the original span and reset their styles
  for (let r = row; r < row + currentRowSpan; r++) {
    for (let c = col; c < col + currentColSpan; c++) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell) {
        cell.style.display = "flex"; // Make sure all cells in the original merged area are visible
        cell.style.gridRow = "";     // Reset their grid properties
        cell.style.gridColumn = "";  // Reset their grid properties
      }
    }
  }
  clearSelections();
  autoSave();
});

// === ãƒ†ã‚­ã‚¹ãƒˆæŒ¿å…¥æ©Ÿèƒ½ ===
function insertTextIntoSelectedCell(text, isBold = false, isCheckbox = false) {
    if (selectedCells.length === 0) {
        alert("ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
        return;
    }
    const targetCell = selectedCells[0];
    const editable = targetCell.querySelector(".editable");
    
    let contentToInsert = '';
    if (isCheckbox) {
        contentToInsert = `
            <div class="checkbox-wrapper">
                <input type="checkbox">
                <span contenteditable="true" class="checkbox-text" ${isBold ? 'style="font-weight: bold;"' : ''}>${text}</span>
            </div>
        `;
    } else {
        contentToInsert = `<div><span contenteditable="true" ${isBold ? 'style="font-weight: bold;"' : ''}>${text}</span></div>`;
    }
    
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = contentToInsert.trim();
    const newElement = tempDiv.firstChild;
    editable.appendChild(newElement);

    if (isCheckbox) {
        attachCheckboxListeners(newElement);
    }
    
    autoSave();
}

document.getElementById("insertCheckboxBtn").addEventListener("click", () => {
    insertTextIntoSelectedCell("task", false, true);
});

document.getElementById("insertBoldCheckboxBtn").addEventListener("click", () => {
    insertTextIntoSelectedCell("task", true, true);
});


// === ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ ===
document.getElementById("uploadImageBtn").addEventListener("click", () => {
  if (selectedCells.length === 0) {
    alert("ç”»åƒæŒ¿å…¥å…ˆã®ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    return;
  }
  document.getElementById("imageInput").click();
});

document.getElementById("imageInput").addEventListener("change", (event) => {
  const file = event.target.files[0];
  if (file && selectedCells.length > 0) {
    const targetCell = selectedCells[0];
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = targetCell.querySelector("img");
      const editable = targetCell.querySelector(".editable");

      editable.innerHTML = "";
      img.src = e.target.result;
      img.style.display = "block";
      autoSave();
    };
    reader.readAsDataURL(file);
  }
});

// === Undo/Reset/Delete ===
document.getElementById("undoBtn").addEventListener("click", () => {
  if (undoHistory.length > 1) { // å°‘ãªãã¨ã‚‚ç¾åœ¨ã®çŠ¶æ…‹ã¨ãã®å‰ã®çŠ¶æ…‹ãŒå¿…è¦
    undoHistory.pop(); // ç¾åœ¨ã®çŠ¶æ…‹ã‚’å‰Šé™¤
    const previousState = undoHistory[undoHistory.length - 1]; // 1ã¤å‰ã®çŠ¶æ…‹ã‚’å–å¾—
    restoreState(previousState);
    console.log("Undo successful. History size:", undoHistory.length);
  } else {
    alert("ã“ã‚Œä»¥ä¸Šæˆ»ã‚‹å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
  }
});

document.getElementById("resetBtn").addEventListener("click", () => {
  if (confirm("ç¾åœ¨ã®ã‚°ãƒªãƒƒãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚")) {
    localStorage.removeItem(`brainhack-${getTodayKey()}`);
    document.querySelectorAll(".cell").forEach(cell => {
      cell.style.display = "flex";
      cell.style.gridRow = "";
      cell.style.gridColumn = "";
      cell.querySelector(".editable").innerHTML = "";
      cell.querySelector("img").src = "";
      cell.querySelector("img").style.display = "none";
      cell.style.backgroundColor = "";
      cell.querySelector(".editable").style.fontSize = "";
      cell.querySelector(".editable").style.alignItems = "";
      cell.querySelector(".editable").style.justifyContent = "";
      cell.querySelector(".editable").style.textAlign = "";
      cell.style.borderColor = "";
      cell.querySelector(".editable").style.color = "";
    });
    document.getElementById("pageTitle").value = "Brain Hacker Home";
    undoHistory.length = 0; // Undoå±¥æ­´ã‚’ã‚¯ãƒªã‚¢
    saveState(true); // ãƒªã‚»ãƒƒãƒˆå¾Œã®ç©ºã®çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜ã—ã€localStorageã«ã‚‚ä¿å­˜
    clearSelections();
    console.log("Grid reset.");
  }
});

document.getElementById("deleteBtn").addEventListener("click", () => {
  if (selectedCells.length === 0) {
    alert("å‰Šé™¤ã™ã‚‹ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  // é¸æŠã•ã‚ŒãŸã‚»ãƒ«ãŒçµåˆã‚»ãƒ«ã®è¦ªã§ã‚ã‚‹å ´åˆã‚’è€ƒæ…®
  selectedCells.forEach((cell) => {
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);

    let currentRowSpan = 1;
    let currentColSpan = 1;

    // ã‚‚ã—çµåˆã‚»ãƒ«ã®å ´åˆã¯ã€ãã®ã‚¹ãƒ‘ãƒ³ã‚’å–å¾—
    if (cell.style.gridRow && cell.style.gridColumn) {
        const computedStyle = window.getComputedStyle(cell);
        const gridRowStart = parseInt(computedStyle.gridRowStart);
        const gridRowEnd = parseInt(computedStyle.gridRowEnd);
        const gridColumnStart = parseInt(computedStyle.gridColumnStart);
        const gridColumnEnd = parseInt(computedStyle.gridColumnEnd);

        currentRowSpan = gridRowEnd - gridRowStart;
        currentColSpan = gridColumnEnd - gridColumnStart;
    }

    // ã‚¹ãƒ‘ãƒ³å†…ã®ã™ã¹ã¦ã®ã‚»ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
    for (let r = row; r < row + currentRowSpan; r++) {
      for (let c = col; c < col + currentColSpan; c++) {
        const affectedCell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
        if (affectedCell) {
          affectedCell.style.display = "flex"; // å¿…ãšè¡¨ç¤ºã«æˆ»ã™
          affectedCell.style.gridRow = "";     // ã‚°ãƒªãƒƒãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ãƒªã‚»ãƒƒãƒˆ
          affectedCell.style.gridColumn = "";  // ã‚°ãƒªãƒƒãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ãƒªã‚»ãƒƒãƒˆ
          affectedCell.querySelector(".editable").innerHTML = ""; // å†…å®¹ã‚’ã‚¯ãƒªã‚¢
          affectedCell.querySelector("img").src = "";             // ç”»åƒã‚’ã‚¯ãƒªã‚¢
          affectedCell.querySelector("img").style.display = "none"; // ç”»åƒã‚’éè¡¨ç¤º
          affectedCell.style.backgroundColor = ""; // èƒŒæ™¯è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
          affectedCell.style.borderColor = ""; // ç½«ç·šè‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
          affectedCell.querySelector(".editable").style.color = ""; // æ–‡å­—è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
        }
      }
    }
  });
  clearSelections();
  autoSave();
});

// === ãƒ†ã‚­ã‚¹ãƒˆé…ç½® ===
document.getElementById('alignTopLeftBtn').addEventListener('click', () => {
    selectedCells.forEach(cell => {
        const editable = cell.querySelector('.editable');
        editable.style.alignItems = 'flex-start';
        editable.style.justifyContent = 'flex-start';
        editable.style.textAlign = 'left';
    });
    autoSave();
});

document.getElementById('alignCenterBtn').addEventListener("click", () => {
    selectedCells.forEach((cell) => {
        const editable = cell.querySelector(".editable");
        editable.style.alignItems = "center";
        editable.style.justifyContent = "center";
        editable.style.textAlign = "center";
    });
    autoSave();
});


// === ã‚·ã‚§ã‚¢æ©Ÿèƒ½ ===
// shareBtn, shareModal, closeShareModalBtn, shareLinkInput, copyBtn ã¯HTMLå†…ã«å®šç¾©ã•ã‚Œã¦ã„ãªã„ãŸã‚ã€
// è©²å½“ã™ã‚‹HTMLè¦ç´ ãŒè¿½åŠ ã•ã‚Œã‚‹ã¾ã§ã€ä»¥ä¸‹ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚
// å¿…è¦ã«å¿œã˜ã¦HTMLã«ã“ã‚Œã‚‰ã®è¦ç´ ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚
/*
const shareModal = document.getElementById("shareModal");
const shareBtn = document.getElementById("shareBtn");
const closeShareModalBtn = shareModal.querySelector(".close-btn");
const shareLinkInput = document.getElementById("shareLink");
const copyBtn = document.getElementById("copyBtn");

shareBtn.addEventListener("click", () => {
  saveState();
  const currentState = localStorage.getItem(`brainhack-${getTodayKey()}`);
  if (currentState) {
    const encodedState = btoa(encodeURIComponent(currentState));
    const shareUrl = `${window.location.origin}${window.location.pathname}?data=${encodedState}`;
    shareLinkInput.value = shareUrl;
    shareModal.style.display = "flex";
  } else {
    alert("å…±æœ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
  }
});

closeShareModalBtn.addEventListener("click", () => {
  shareModal.style.display = "none";
});

copyBtn.addEventListener("click", () => {
  shareLinkInput.select();
  document.execCommand("copy");
  alert("ãƒªãƒ³ã‚¯ãŒã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸï¼");
  shareModal.style.display = "none";
});

window.addEventListener("click", (event) => {
  if (event.target === shareModal) {
    shareModal.style.display = "none";
  }
});
*/

// === åˆæœŸãƒ­ãƒ¼ãƒ‰ ===
document.addEventListener("DOMContentLoaded", () => {
  // restoreStateã‚’å‘¼ã³å‡ºã—ã€åˆæœŸãƒ­ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ãŸã‚ã«å¼•æ•°ã‚’æ¸¡ã•ãªã„
  restoreState();
  
  // pageTitleã®inputã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯DOMContentLoadedå¤–ã§ã‚¢ã‚¿ãƒƒãƒã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€é‡è¤‡ç¢ºèªä¸è¦
  // å„editable divã«inputãƒªã‚¹ãƒŠãƒ¼ãŒç¢ºå®Ÿã«ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
  document.querySelectorAll('.editable').forEach(editableDiv => {
      editableDiv.removeEventListener("input", autoSave); // é‡è¤‡é˜²æ­¢
      editableDiv.addEventListener("input", autoSave);
  });
});

</script>
</body>
</html>