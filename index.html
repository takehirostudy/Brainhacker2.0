<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brain Hacker</title>
  <style>
    /* CSS„Åì„Åì„Åã„Çâ */
    body {
      margin: 0;
      padding: 15px;
      font-family: sans-serif;
      background-color: #f5f5f5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      min-height: 40px;
    }

    .title-area {
      flex-grow: 1;
    }

    .nav-buttons {
      display: flex;
      gap: 10px;
    }

    .nav-btn {
      padding: 8px 15px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 5px;
      text-decoration: none;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .nav-btn:hover {
      background-color: #3367d6;
    }

    .title-input {
      font-size: 2em;
      width: 100%;
      border: none;
      background-color: transparent;
      color: #333;
      outline: none;
      text-align: center;
      margin: 0 0 10px 0;
    }

    .title-input::placeholder {
      color: #999;
    }

    #dateDisplay {
      font-weight: bold;
      font-size: 1.2em;
      margin-bottom: 0; /* „Åì„Çå„Åå‰øÆÊ≠£ÁÇπ */
      color: #333;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 15px;
      background-color: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    button {
      padding: 6px 10px;
      font-size: 14px;
      background-color: #e8f0fe;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      color: #333;
    }

    button:hover {
      background-color: #e9e9e9;
    }

    .color-btn {
      width: 24px;
      height: 24px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
    }

    .size-btn {
      width: 32px;
      height: 32px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #e8f0fe;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid-container {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(16, 1fr);
      width: 100%;
      height: 75vh;
      gap: 1px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 2px;
    }

    .cell {
      border: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      padding: 1px;
      font-size: 1vw;
      background-color: white;
      position: relative;
      box-sizing: border-box;
    }

    .cell.selected {
      outline: 2px solid #4285f4;
    }

    .editable {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      flex-direction: column; /* Changed to column to stack inline elements like .checkbox-wrapper */
      font-size: 1vw;
      text-align: left;
      padding: 2px;
      border: none;
      outline: none;
      overflow: auto;
      white-space: pre-wrap; /* Preserve whitespace and allow wrapping */
      word-break: break-word; /* Break long words */
    }

    .cell img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    /* History Modal specific styles (record.htmlÁî®„Å™„ÅÆ„Åßindex.html„Åß„ÅØÊú¨Êù•‰∏çË¶Å) */
    .history-modal-content {
      background-color: #fefefe;
      margin: 5% auto; /* Adjust margin for more space */
      padding: 20px;
      border-radius: 5px;
      width: 90%; /* Wider for better content display */
      max-width: 800px; /* Max width for readability */
      height: 80%; /* Adjust height */
      overflow-y: auto; /* Enable scrolling for content */
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .history-grid-display {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(16, 1fr);
      width: 100%;
      height: auto; /* Adjust height based on content */
      min-height: 400px; /* Minimum height for visibility */
      gap: 1px;
      background-color: #eee;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 2px;
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }

    .history-cell {
      border: 1px solid #eee;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1px;
      font-size: 0.8vw; /* Smaller font size for history view */
      background-color: white;
      overflow: hidden; /* Hide overflow content */
      text-align: left;
      word-break: break-word;
      white-space: pre-wrap;
    }

    .history-cell .editable {
        all: unset; /* Reset all editable styles for static display */
        font-size: 0.8vw; /* Keep consistent font size */
        padding: 2px;
        color: #333;
        overflow: hidden; /* Hide overflow for static display */
        text-overflow: ellipsis; /* Add ellipsis for overflowing text */
        display: -webkit-box;
        -webkit-line-clamp: 3; /* Limit to 3 lines */
        -webkit-box-orient: vertical;
    }

    /* „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆÊîπË°åÈñìÈöî„ÇíÁã≠„ÇÅ„Çã„Åü„ÇÅ„ÅÆ„Çπ„Çø„Ç§„É´ */
    /* „Åì„Åì„Åã„Çâ‰øÆÊ≠£„Åï„Çå„ÅüCSS */
    .checkbox-wrapper {
      display: flex; /* Ensures checkbox and text are on the same line */
      align-items: flex-start; /* Aligns checkbox and text at the top*/
      margin-bottom: 2px;
      line-height: 1.5;
      width: 100%; /* Ensures the wrapper takes full width*/
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }

    .checkbox-wrapper input[type="checkbox"] {
      margin-right: 5px;
      margin-top: 2px; /* Adjust as needed for vertical alignment*/
      flex-shrink: 0; /* Prevent checkbox from shrinking*/
    }

    .checkbox-text {
      flex-grow: 1; /* Allows text to take up remaining space*/
      word-break: break-word;
      white-space: pre-wrap;
      min-width: 0; /* Allows text to shrink within the flex container*/
    }

    .checkbox-text.checked-item {
      text-decoration: line-through;
      color: #888;
    }
    /* „Åì„Åì„Åæ„Åß‰øÆÊ≠£„Åï„Çå„ÅüCSS */

  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title-area">
        <div id="dateDisplay"></div>
      </div>
      <div class="nav-buttons">
        <a href="record.html" class="nav-btn">Record</a>
      </div>
    </div>

    <input class="title-input" id="pageTitle" placeholder="Brain Hacker Home" />

    <div class="controls">
      <button class="color-btn" data-color="#ffa500" style="background-color:#ffa500;"></button>
      <button class="color-btn" data-color="#f2c1c1" style="background-color:#f2c1c1;"></button>
      <button class="color-btn" data-color="#ffef5b" style="background-color:#ffef5b;"></button>
      <button class="color-btn" data-color="#d0f0c0" style="background-color:#d0f0c0;"></button>
      <button class="color-btn" data-color="#a2dff7" style="background-color:#a2dff7;"></button>
      <button class="color-btn" data-color="#d8d8d8" style="background-color:#d8d8d8;"></button>
      <button class="color-btn" data-color="#ffffff" style="background-color:#ffffff;"></button>
      <button id="mergeBtn">integrate</button>
      <button id="splitBtn">separate</button>
      <button id="insertCheckboxBtn">‚úÖ check</button>
      <button id="insertBoldCheckboxBtn">‚òëÔ∏è check</button>
      <button id="insertNoteBtn">üìù note</button> <button id="uploadImageBtn">üñºÔ∏è</button>
      <input type="file" id="imageInput" accept="image/*" style="display: none;" />
      <button class="size-btn" data-size="2.56vw" style="font-size:2.56vw;">A</button>
      <button class="size-btn" data-size="1.92vw" style="font-size:1.92vw;">A</button>
      <button class="size-btn" data-size="1.6vw" style="font-size:1.6vw;">A</button>
      <button class="size-btn" data-size="1.0vw" style="font-size:1.0vw;">A</button>
      <button class="size-btn" data-size="0.6vw" style="font-size:0.6vw;">A</button>
      <button id="undoBtn">‚Ü©Ô∏è</button> <button id="resetBtn">üîÑ</button>
      <button id="deleteBtn">üóëÔ∏è</button>
      <button id="alignTopLeftBtn">left alignment</button>
      <button id="alignCenterBtn">centered</button>
    </div>

    <div class="grid-container" id="grid"></div>
  </div>

  <script>
// === Êó•‰ªò„Å®„Çø„Ç§„Éà„É´ ===
function getTodayKey() {
  const now = new Date();
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
}
function getYesterdayKey() {
  const now = new Date();
  now.setDate(now.getDate() - 1);
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
}
document.getElementById("dateDisplay").textContent = `${getTodayKey()} (${["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][new Date().getDay()]})`;

// === Ëá™Âãï‰øùÂ≠ò„ÅÆ„Åü„ÇÅ„ÅÆDebounceÊ©üËÉΩ ===
let autoSaveTimeout;
const AUTO_SAVE_DELAY = 1000; // 1Áßí (1000ms)

function autoSave() {
  clearTimeout(autoSaveTimeout);
  autoSaveTimeout = setTimeout(() => {
    saveState();
    console.log("Grid state automatically saved.");
  }, AUTO_SAVE_DELAY);
}

// === Áä∂ÊÖã‰øùÂ≠ò„Å®Âæ©ÂÖÉÔºàUndoÊ©üËÉΩ„ÅÆ„Åü„ÇÅ„Å´Â±•Ê≠¥„ÇíÁÆ°ÁêÜÔºâ ===
const undoHistory = [];
const MAX_HISTORY = 20; // ‰øùÂ≠ò„Åô„ÇãÂ±•Ê≠¥„ÅÆÊúÄÂ§ßÊï∞

function saveState() {
  const state = [...document.querySelectorAll(".cell")].map(cell => {
    const editable = cell.querySelector(".editable");
    const img = cell.querySelector("img");
    // „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆÁä∂ÊÖã„ÇíHTML„Å´ÂèçÊò†„Åï„Åõ„Çã (ÈáçË¶Å)
    if (editable) { // editable„ÅåÂ≠òÂú®„Åô„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
        editable.querySelectorAll("input[type='checkbox']").forEach(cb => {
            // isChecked „Éó„É≠„Éë„ÉÜ„Ç£„ÇíÁõ¥Êé•Ë™≠„ÅøÂèñ„Çã
            cb.checked ? cb.setAttribute("checked", "checked") : cb.removeAttribute("checked");
            // „Åæ„Åü„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Çπ„Çø„Ç§„É´„ÇÇ‰øùÂ≠òÊôÇ„Å´Êõ¥Êñ∞„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
            const textSpan = cb.nextElementSibling;
            if (textSpan) {
                textSpan.classList.toggle('checked-item', cb.checked);
            }
        });
    }

    return {
      row: cell.dataset.row,
      col: cell.dataset.col,
      html: editable ? editable.innerHTML : '', // editable„Åånull„ÅÆÂ†¥Âêà„Å´ÂÇô„Åà„Çã
      fontSize: editable ? editable.style.fontSize : '',
      bgColor: cell.style.backgroundColor,
      display: cell.style.display,
      gridRow: cell.style.gridRow,
      gridColumn: cell.style.gridColumn,
      imgSrc: (img && img.src && img.src !== "undefined" && img.src !== "null" && img.style.display !== 'none') ? img.src : "",
      alignItems: editable ? editable.style.alignItems : '',
      justifyContent: editable ? editable.style.justifyContent : '',
      textAlign: editable ? editable.style.textAlign : ''
    };
  });

  const fullState = {
    title: document.getElementById("pageTitle").value,
    date: getTodayKey(),
    cells: state
  };

  // Save to localStorage for daily persistence
  localStorage.setItem(`brainhack-${getTodayKey()}`, btoa(encodeURIComponent(JSON.stringify(fullState))));

  // Add to undo history
  undoHistory.push(JSON.parse(JSON.stringify(fullState))); // Deep copy
  if (undoHistory.length > MAX_HISTORY) {
    undoHistory.shift(); // Remove oldest state
  }
  console.log("State saved. History size:", undoHistory.length);
}

// === „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çí„Ç¢„Çø„ÉÉ„ÉÅ„Åô„ÇãÂÖ±ÈÄöÈñ¢Êï∞ ===
function attachCheckboxListeners(containerElement) {
    if (!containerElement) return;
    containerElement.querySelectorAll("input[type='checkbox']").forEach(cb => {
        // Êó¢Â≠ò„ÅÆ„É™„Çπ„Éä„Éº„ÇíÂâäÈô§ (‰∫åÈáçÁôªÈå≤Èò≤Ê≠¢)
        cb.removeEventListener("change", handleCheckboxChange);
        // Êñ∞„Åó„ÅÑ„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
        cb.addEventListener("change", handleCheckboxChange);

        // „É≠„Éº„ÉâÊôÇ„Å´ÂàùÊúüÁä∂ÊÖã„ÇíÈÅ©Áî®
        const textSpan = cb.nextElementSibling;
        if (textSpan && textSpan.classList.contains('checkbox-text')) {
            textSpan.classList.toggle('checked-item', cb.checked);
        }
    });
}

// handleCheckboxChange Èñ¢Êï∞„Çí‰øÆÊ≠£
function handleCheckboxChange(event) {
    const checkbox = event.target;
    const wrapper = checkbox.closest('.checkbox-wrapper');
    if (!wrapper) return;

    const textSpan = wrapper.querySelector('.checkbox-text');
    if (textSpan) {
        textSpan.classList.toggle('checked-item', checkbox.checked);
    }
    autoSave();
}


function restoreState(stateToRestore) {
  clearSelections(); // Clear selections before restoring

  let state;
  let isLoadedFromLocalStorage = false;

  // If restoring from localStorage (initial load or explicit restore)
  if (!stateToRestore) {
    const compressed = localStorage.getItem(`brainhack-${getTodayKey()}`);
    if (compressed) {
      try {
        state = JSON.parse(decodeURIComponent(atob(compressed))); // Decode and parse
        isLoadedFromLocalStorage = true;
      } catch (e) {
        console.error("Failed to load today's grid state from localStorage:", e);
        // Fallback to yesterday's state if today's is corrupted
      }
    }

    if (!state) { // Check for yesterday's state if today's is empty or corrupted
      const yCompressed = localStorage.getItem(`brainhack-${getYesterdayKey()}`);
      if (yCompressed) {
        try {
          const parsed = JSON.parse(decodeURIComponent(atob(yCompressed)));
          parsed.cells.forEach(c => {
            const temp = document.createElement("div");
            temp.innerHTML = c.html;

            // Â§™Â≠ó„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„ÇπÈ†ÖÁõÆ„ÇíÂâäÈô§ (Â§™Â≠ó„ÅØÊåÅ„Å°Ë∂ä„Åï„Å™„ÅÑ)
            const filteredNodes = [...temp.childNodes].filter(node => {
              // <div>.checkbox-wrapper > <input> + <span> ÊßãÈÄ†„Å´ÂØæÂøú
              const wrapper = node.classList?.contains('checkbox-wrapper') ? node : null;
              const cb = wrapper ? wrapper.querySelector("input[type='checkbox']") : null;
              const sp = cb ? cb.nextElementSibling : null; // span.checkbox-text

              return !(cb && sp?.style.fontWeight === "bold"); // Â§™Â≠ó„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
            });

            // ÈÄöÂ∏∏„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Å®Âèñ„ÇäÊ∂à„ÅóÁ∑ö„Çí„É™„Çª„ÉÉ„Éà
            filteredNodes.forEach(node => {
              const cb = node.querySelector?.("input[type='checkbox']");
              const sp = cb ? cb.nextElementSibling : null; // span.checkbox-text
              if (cb && sp && !sp.style.fontWeight.includes("bold")) {
                cb.removeAttribute("checked");
                // „ÇØ„É©„Çπ„ÇíÂâäÈô§„Åó„Å¶„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
                sp.classList.remove("checked-item");
              }
            });

            const wrapper = document.createElement("div");
            filteredNodes.forEach(n => wrapper.appendChild(n.cloneNode(true)));
            c.html = wrapper.innerHTML;
          });
          state = {
              title: parsed.title,
              date: getTodayKey(), // Set today's date for restored content
              cells: parsed.cells
          };
          // Save the restored yesterday's state as today's state
          localStorage.setItem(`brainhack-${getTodayKey()}`, btoa(encodeURIComponent(JSON.stringify(state))));
          isLoadedFromLocalStorage = true;
        } catch (e) {
            console.error("Failed to load yesterday's grid state from localStorage:", e);
        }
      }
    }
  } else {
      state = stateToRestore; // Use provided state for undo
  }

  if (!state) return;
  const parsedFullState = typeof state === 'string' ? JSON.parse(state) : state;
  const parsedCells = parsedFullState.cells;

  document.getElementById("pageTitle").value = parsedFullState.title || "Brain Hacker Home";

  // Reset all cells to default before applying state, crucial for merge/split fix
  document.querySelectorAll(".cell").forEach(cell => {
    cell.style.display = "flex";
    cell.style.gridRow = "";
    cell.style.gridColumn = "";
    const editable = cell.querySelector(".editable");
    const img = cell.querySelector("img");
    if (editable) editable.innerHTML = "";
    if (img) {
        img.src = "";
        img.style.display = "none";
    }
    cell.style.backgroundColor = "";
    if (editable) {
        editable.style.fontSize = "";
        editable.style.alignItems = "";
        editable.style.justifyContent = "";
        editable.style.textAlign = "";
    }
  });

  parsedCells.forEach(data => {
    const cell = document.querySelector(`.cell[data-row='${data.row}'][data-col='${data.col}']`);
    if (!cell) {
        console.warn(`Cell not found for row: ${data.row}, col: ${data.col}. Skipping.`);
        return; // cell „Åå null „Å™„Çâ„Å∞„ÄÅ„Åì„ÅÆ„Çª„É´„Å´Èñ¢„Åô„ÇãÂá¶ÁêÜ„ÅØ„Çπ„Ç≠„ÉÉ„Éó
    }

    const editable = cell.querySelector(".editable");
    const img = cell.querySelector("img");

    // editable „Åæ„Åü„ÅØ img „Åå null „Å™„Çâ„Å∞„ÄÅ„Åì„ÅÆ„Çª„É´„ÅÆË¶ÅÁ¥†Âá¶ÁêÜ„Çí„Çπ„Ç≠„ÉÉ„Éó
    // „Åü„Å†„Åó„ÄÅ„Åì„Çå„Çâ„ÅØHTML„Å´Â∏∏„Å´Â≠òÂú®„Åô„Çã„Åü„ÇÅ„ÄÅÈÄöÂ∏∏„ÅØnull„Å´„Å™„Çâ„Å™„ÅÑ„ÅØ„Åö
    if (!editable || !img) {
        console.warn(`Editable or Image element not found in cell at row: ${data.row}, col: ${data.col}. Skipping part of restoration.`);
        return;
    }

    editable.innerHTML = typeof data.html === 'string' ? data.html : "";

    editable.style.fontSize = data.fontSize || "";
    editable.style.alignItems = data.alignItems || "";
    editable.style.justifyContent = data.justifyContent || ""; // justifyContent„Å®alignItems„ÅåÂêå„Åò„Å´„Å™„Å£„Å¶„ÅÑ„Åü„Åü„ÇÅ‰øÆÊ≠£
    editable.style.textAlign = data.textAlign || "";

    cell.style.backgroundColor = data.bgColor || "";
    cell.style.display = data.display || "flex"; // Default to flex if display is not set
    cell.style.gridRow = data.gridRow || "";
    cell.style.gridColumn = data.gridColumn || "";

    if (data.imgSrc && data.imgSrc.startsWith("data:image/")) {
      img.src = data.imgSrc;
      img.style.display = "block";
    } else {
      img.src = "";
      img.style.display = "none";
    }

    // `editable` „ÅÆÂÜÖÂÆπ„Çí„Çª„ÉÉ„Éà„Åó„ÅüÂæå„ÄÅ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„É™„Çπ„Éä„Éº„Çí„Ç¢„Çø„ÉÉ„ÉÅ
    attachCheckboxListeners(editable);
  });
  console.log("State restored.");

  // ÊúÄÂàù„ÅÆ„É≠„Éº„ÉâÊôÇ„Å´Â±•Ê≠¥„Å´ËøΩÂä†
  if (isLoadedFromLocalStorage && undoHistory.length === 0) {
      // isLoadedFromLocalStorage „Åå true „ÅÆÂ†¥Âêà„ÄÅparsedFullState „ÅØ LocalStorage „Åã„Çâ„É≠„Éº„Éâ„Åï„Çå„ÅüÁä∂ÊÖã
      // „Åì„Çå„Çí undoHistory „Å´ËøΩÂä†„Åó„Å¶„ÄÅÊúÄÂàù„ÅÆUndo„Åß„Åì„ÅÆÁä∂ÊÖã„Å´Êàª„Çå„Çã„Çà„ÅÜ„Å´„Åô„Çã
      undoHistory.push(JSON.parse(JSON.stringify(parsedFullState)));
  }
}


// === „Ç∞„É™„ÉÉ„ÉâÁîüÊàê ===
const pageTitle = document.getElementById("pageTitle");
// pageTitle„ÅÆinput„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíautoSave„ÇíÂëº„Å≥Âá∫„Åô„Çà„ÅÜ„Å´Â§âÊõ¥
pageTitle.removeEventListener("input", saveState); // Êó¢Â≠ò„ÅÆsaveState„ÇíÂâäÈô§
pageTitle.addEventListener("input", () => {
    // localStorage.setItem("pageTitle", document.getElementById("pageTitle").value); // „Åì„ÅÆË°å„ÅØÂÜóÈï∑„Å™„ÅÆ„ÅßÂâäÈô§
    autoSave(); // Title change should also autoSave
});

const grid = document.getElementById("grid");
for (let row = 0; row < 16; row++) {
  for (let col = 0; col < 20; col++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.dataset.row = row;
    cell.dataset.col = col;
    cell.setAttribute("tabindex", "0"); // Make cells focusable

    const editable = document.createElement("div");
    editable.className = "editable";
    editable.setAttribute("contenteditable", "true");

    // editable „ÅÆÂÜÖÂÆπÂ§âÊõ¥ÊôÇ„Å´ autoSave „ÇíÂëº„Å≥Âá∫„Åô
    // editable.removeEventListener("input", saveState); // Êó¢Â≠ò„ÅÆsaveState„ÇíÂâäÈô§ (Âøµ„ÅÆ„Åü„ÇÅ)
    editable.addEventListener("input", autoSave);

    const img = document.createElement("img");
    img.style.display = "none"; // Initially hidden

    cell.appendChild(editable);
    cell.appendChild(img);
    grid.appendChild(cell);

    // Initial state for each cell - No need to push to undoHistory here.
    // The initial state will be correctly handled by DOMContentLoaded -> restoreState -> saveState.
  }
}


// --- „Çª„É´ÈÅ∏Êäû„É≠„Ç∏„ÉÉ„ÇØ ---
let selectedCells = [];
let isMouseDown = false;
let startCell = null;

grid.addEventListener("mousedown", (e) => {
  if (e.target.closest(".cell")) {
    isMouseDown = true;
    startCell = e.target.closest(".cell");
    clearSelections();
    toggleCellSelection(startCell);
  }
});

grid.addEventListener("mouseover", (e) => {
  if (isMouseDown && e.target.closest(".cell")) {
    const currentCell = e.target.closest(".cell");
    if (startCell && currentCell) {
      selectRange(startCell, currentCell);
    }
  }
});

grid.addEventListener("mouseup", () => {
  isMouseDown = false;
  startCell = null;
});

document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    clearSelections();
  }
});

function clearSelections() {
  selectedCells.forEach((cell) => cell.classList.remove("selected"));
  selectedCells = [];
}

function toggleCellSelection(cell) {
  if (!cell) return;
  cell.classList.toggle("selected");
  if (cell.classList.contains("selected")) {
    selectedCells.push(cell);
  } else {
    selectedCells = selectedCells.filter((c) => c !== cell);
  }
}

function selectRange(start, end) {
  clearSelections();
  const startRow = parseInt(start.dataset.row);
  const startCol = parseInt(start.dataset.col);
  const endRow = parseInt(end.dataset.row);
  const endCol = parseInt(end.dataset.col);

  const minRow = Math.min(startRow, endRow);
  const maxRow = Math.max(startRow, endRow);
  const minCol = Math.min(startCol, endCol);
  const maxCol = Math.max(startCol, endCol);

  for (let r = minRow; r <= maxRow; r++) {
    for (let c = minCol; c <= maxCol; c++) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell) {
        cell.classList.add("selected");
        selectedCells.push(cell);
      }
    }
  }
}

// --- „Ç≥„É≥„Éà„É≠„Éº„É´„Éú„Çø„É≥Ê©üËÉΩ ---
document.querySelectorAll(".color-btn").forEach((button) => {
  button.addEventListener("click", () => {
    const color = button.dataset.color;
    selectedCells.forEach((cell) => {
      cell.style.backgroundColor = color;
    });
    autoSave();
  });
});

document.querySelectorAll(".size-btn").forEach((button) => {
  button.addEventListener("click", () => {
    selectedCells.forEach((cell) => {
      const editable = cell.querySelector(".editable");
      if (editable) { // editable„ÅåÂ≠òÂú®„Åô„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
        editable.style.fontSize = button.dataset.size;
      }
    });
    autoSave();
  });
});

document.getElementById("mergeBtn").addEventListener("click", () => {
  if (selectedCells.length < 2) {
    alert("ÁµêÂêà„Åô„Çã„Å´„ÅØ2„Å§‰ª•‰∏ä„ÅÆ„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    return;
  }

  // Calculate bounding box of selected cells
  let minRow = Infinity, maxRow = -Infinity, minCol = Infinity, maxCol = -Infinity;
  selectedCells.forEach(cell => {
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    minRow = Math.min(minRow, row);
    maxRow = Math.max(maxRow, row);
    minCol = Math.min(minCol, col);
    maxCol = Math.max(maxCol, col);
  });

  const rowSpan = maxRow - minRow + 1;
  const colSpan = maxCol - minCol + 1;

  const firstCell = document.querySelector(`.cell[data-row='${minRow}'][data-col='${minCol}']`);
  if (!firstCell) return;

  let combinedHtmlContent = []; // ÂêÑ„Çª„É´„ÅÆHTMLÂÜÖÂÆπ„ÇíÊ†ºÁ¥ç„Åô„ÇãÈÖçÂàó
  let previousRow = minRow;

  // „ÇΩ„Éº„Éà„Åï„Çå„Åü„Çª„É´„Çí„É´„Éº„Éó„Åó„Å¶„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÇíÁµêÂêà
  selectedCells.sort((a, b) => {
      const rowA = parseInt(a.dataset.row);
      const colA = parseInt(a.dataset.col);
      const rowB = parseInt(b.dataset.row);
      const colB = parseInt(b.dataset.col);
      if (rowA !== rowB) return rowA - rowB;
      return colA - colB;
  }).forEach(cell => {
      const currentRow = parseInt(cell.dataset.row);
      // Ë°å„ÅåÂ§â„Çè„Çã„Åü„Å≥„Å´„ÄÅÂå∫Âàá„Çä„ÇíÂÖ•„Çå„Çã„Åã„ÄÅÊñ∞„Åó„ÅÑË°å„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ§∫„Åô„Åü„ÇÅ„Å´‰Ωï„Çâ„Åã„ÅÆ„Éû„Éº„ÇØ„ÇíÂÖ•„Çå„Çã
      if (currentRow > previousRow && combinedHtmlContent.length > 0) {
          combinedHtmlContent.push('<br><hr>'); // Ë¶ñË¶öÁöÑ„Å™Âå∫Âàá„Çä„Å®„Åó„Å¶HR„Çø„Ç∞„ÇíËøΩÂä†
      }
      const editableContent = cell.querySelector(".editable")?.innerHTML.trim();
      if (editableContent) {
          combinedHtmlContent.push(editableContent);
      }
      previousRow = currentRow;
  });

  const firstCellEditable = firstCell.querySelector(".editable");
  if (firstCellEditable) {
      // Êó¢Â≠ò„ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅØ„Åù„ÅÆ„Åæ„ÅæÊÆã„Åó„ÄÅÊñ∞„Åó„ÅÑ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çí„Åù„ÅÆÂæå„Å´ËøΩÂä†
      // „ÅÇ„Çã„ÅÑ„ÅØ„ÄÅÂÆåÂÖ®„Å´ÂÜçÊßãÁØâ„Åô„Çã„Åü„ÇÅ„Å´ clear „Åó„Å¶„Åã„ÇâËøΩÂä†
      // ‰æã: firstCellEditable.innerHTML = ""; // Êó¢Â≠ò„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çí„ÇØ„É™„Ç¢„Åô„ÇãÂ†¥Âêà
      if (firstCellEditable.innerHTML.trim() !== "" && combinedHtmlContent.length > 0) {
          // firstCellËá™Ë∫´„Å´ÂÜÖÂÆπ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅÁµêÂêà„Åï„Çå„ÇãÂÜÖÂÆπ„Å®„ÅÆÈñì„Å´Âå∫Âàá„Çä„ÇíÂÖ•„Çå„Çã
          firstCellEditable.innerHTML += '<br><hr>' + combinedHtmlContent.join('<br>');
      } else {
          firstCellEditable.innerHTML = combinedHtmlContent.join('<br>');
      }

      attachCheckboxListeners(firstCellEditable);
  }

  // Apply grid styles to the first cell
  firstCell.style.gridRow = `span ${rowSpan}`;
  firstCell.style.gridColumn = `span ${colSpan}`;

  // Hide other selected cells
  selectedCells.forEach(cell => {
    if (cell !== firstCell) {
      cell.style.display = "none";
      const editable = cell.querySelector(".editable");
      if(editable) editable.innerHTML = ""; // Clear content of hidden cells
      const img = cell.querySelector("img");
      if (img) { img.src = ""; img.style.display = "none"; }
    }
  });

  clearSelections();
  autoSave();
});

document.getElementById("splitBtn").addEventListener("click", () => {
  if (selectedCells.length !== 1) {
    alert("ÂàÜÂâ≤„Åô„Çã„Å´„ÅØ1„Å§„ÅÆÁµêÂêà„Åï„Çå„Åü„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    return;
  }

  const mergedCell = selectedCells[0];
  const startRow = parseInt(mergedCell.dataset.row);
  const startCol = parseInt(mergedCell.dataset.col);
  const rowSpan = parseInt(mergedCell.style.gridRow.replace("span ", "") || "1");
  const colSpan = parseInt(mergedCell.style.gridColumn.replace("span ", "") || "1");

  // Restore original display and clear grid-span styles
  mergedCell.style.gridRow = "";
  mergedCell.style.gridColumn = "";
  mergedCell.style.display = "flex"; // Ensure it's visible

  // Restore other cells that were hidden
  for (let r = startRow; r < startRow + rowSpan; r++) {
    for (let c = startCol; c < startCol + colSpan; c++) {
      const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
      if (cell && cell !== mergedCell) {
        cell.style.display = "flex";
      }
    }
  }
  clearSelections();
  autoSave();
});

document.getElementById("insertCheckboxBtn").addEventListener("click", () => {
  if (selectedCells.length === 0) {
    alert("„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    return;
  }
  selectedCells.forEach(cell => {
    const editable = cell.querySelector(".editable");
    if (editable) {
        const selection = window.getSelection();
        const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;

        // ÊîπË°å„ÇíËøΩÂä†ÔºàÊó¢„Å´„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
        if (editable.innerHTML.trim() !== "" && (!range || !editable.contains(range.commonAncestorContainer))) {
            editable.appendChild(document.createElement('br'));
        }

        const checkboxWrapper = document.createElement('div');
        checkboxWrapper.className = 'checkbox-wrapper';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const textSpan = document.createElement('span');
        textSpan.className = 'checkbox-text';
        textSpan.contentEditable = 'true';
        textSpan.textContent = ' ';

        checkboxWrapper.appendChild(checkbox);
        checkboxWrapper.appendChild(textSpan);

        if (range && editable.contains(range.commonAncestorContainer)) {
            range.deleteContents();
            range.insertNode(checkboxWrapper);
            // Êñ∞„Åó„ÅÑRange„Çí‰ΩúÊàê„Åó„ÄÅtextSpan„ÅÆÊú´Â∞æ„Å´„Ç´„Éº„ÇΩ„É´„ÇíÁßªÂãï
            const newRange = document.createRange();
            newRange.setStart(textSpan, 1);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
        } else {
            editable.appendChild(checkboxWrapper);
            const newRange = document.createRange();
            const newSelection = window.getSelection();
            newRange.setStart(textSpan, 1);
            newRange.collapse(true);
            newSelection.removeAllRanges();
            newSelection.addRange(newRange);
        }
        attachCheckboxListeners(checkboxWrapper);
    }
  });
  autoSave();
});

// This is the correct definition for insertBoldCheckboxBtn
document.getElementById("insertBoldCheckboxBtn").addEventListener("click", () => {
  if (selectedCells.length === 0) {
    alert("„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    return;
  }
  selectedCells.forEach(cell => {
    const editable = cell.querySelector(".editable");
    if (editable) {
        const selection = window.getSelection();
        const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;

        const checkboxWrapper = document.createElement('div');
        checkboxWrapper.className = 'checkbox-wrapper';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        const textSpan = document.createElement('span');
        textSpan.className = 'checkbox-text';
        textSpan.contentEditable = 'true';
        textSpan.style.fontWeight = 'bold'; // Â§™Â≠ó„Çπ„Çø„Ç§„É´„ÇíÈÅ©Áî®
        textSpan.textContent = ' '; // ÂàùÊúü„ÉÜ„Ç≠„Çπ„Éà„Å®„Åó„Å¶„Çπ„Éö„Éº„Çπ„ÇíÊåøÂÖ•

        checkboxWrapper.appendChild(checkbox);
        checkboxWrapper.appendChild(textSpan);

        if (range && editable.contains(range.commonAncestorContainer)) {
            range.deleteContents();
            range.insertNode(checkboxWrapper);

            const newRange = document.createRange(); // Êñ∞„Åó„ÅÑRange„Çí‰ΩúÊàê
            newRange.setStart(textSpan, 1);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange); // newRange „Çí‰Ωø„ÅÜ
        } else {
            editable.appendChild(checkboxWrapper);
            const newRange = document.createRange();
            const newSelection = window.getSelection();
            newRange.setStart(textSpan, 1);
            newRange.collapse(true);
            newSelection.removeAllRanges();
            newSelection.addRange(newRange);
        }
        attachCheckboxListeners(checkboxWrapper); // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çí„Ç¢„Çø„ÉÉ„ÉÅ
    }
  });
  autoSave();
});

document.getElementById("insertNoteBtn").addEventListener("click", () => {
    if (selectedCells.length === 0) {
        alert("„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
        return;
    }
    selectedCells.forEach(cell => {
        const editable = cell.querySelector(".editable");
        if (editable) {
            const selection = window.getSelection();
            const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;

            const noteSpan = document.createElement('span');
            noteSpan.contentEditable = 'true';
            noteSpan.style.display = 'block'; // Block display for new line
            noteSpan.style.color = '#555'; // Adjust color for notes
            noteSpan.style.fontStyle = 'italic'; // Italic style for notes
            noteSpan.textContent = ' '; // Initial text

            if (range && editable.contains(range.commonAncestorContainer)) {
                range.deleteContents();
                range.insertNode(noteSpan);
                range.setStart(noteSpan, 1);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                editable.appendChild(noteSpan);
                const newRange = document.createRange();
                const newSelection = window.getSelection();
                newRange.setStart(noteSpan, 1);
                newRange.collapse(true);
                newSelection.removeAllRanges();
                newSelection.addRange(newRange);
            }
        }
    });
    autoSave();
});

document.getElementById("uploadImageBtn").addEventListener("click", () => {
    document.getElementById("imageInput").click();
});

document.getElementById("imageInput").addEventListener("change", (event) => {
    if (selectedCells.length === 0) {
        alert("„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
        return;
    }
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            selectedCells.forEach(cell => {
                const img = cell.querySelector("img");
                const editable = cell.querySelector(".editable"); // editable„ÇÇÂèñÂæó
                if (img) {
                    img.src = e.target.result;
                    img.style.display = "block";
                    if (editable) editable.innerHTML = ""; // ÁîªÂÉè„ÇíÊåøÂÖ•„Åó„Åü„Çâ„ÉÜ„Ç≠„Çπ„Éà„Çí„ÇØ„É™„Ç¢
                }
            });
            autoSave();
        };
        reader.readAsDataURL(file);
    }
});


document.getElementById("undoBtn").addEventListener("click", () => {
  if (undoHistory.length > 1) { // Current state is always the last one
    undoHistory.pop(); // Remove current state
    const previousState = undoHistory[undoHistory.length - 1];
    if (previousState) {
      restoreState(previousState);
    } else {
      // If no history, clear the grid
      document.querySelectorAll(".cell").forEach(cell => {
        const editable = cell.querySelector(".editable");
        const img = cell.querySelector("img"); // ‰øÆÊ≠£ÁÆáÊâÄ
        if (editable) editable.innerHTML = "";
        if (img) { img.src = ""; img.style.display = "none"; }
        cell.style.backgroundColor = "";
        cell.style.gridRow = "";
        cell.style.gridColumn = "";
        cell.style.display = "flex";
      });
      document.getElementById("pageTitle").value = "Brain Hacker Home";
    }
    console.log("Undo performed. History size:", undoHistory.length);
  } else {
    alert("„Åì„Çå‰ª•‰∏äÊàª„ÇãÂ±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ");
  }
});


document.getElementById("resetBtn").addEventListener("click", () => {
    if (confirm("ÂÖ®„Å¶„ÅÆ„Ç∞„É™„ÉÉ„ÉâÂÜÖÂÆπ„Å®Ë®≠ÂÆö„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ")) {
        localStorage.removeItem(`brainhack-${getTodayKey()}`);
        document.querySelectorAll(".cell").forEach(cell => {
            const editable = cell.querySelector(".editable");
            const img = cell.querySelector("img"); // ‰øÆÊ≠£ÁÆáÊâÄ
            if (editable) editable.innerHTML = "";
            if (img) { img.src = ""; img.style.display = "none"; }
            cell.style.backgroundColor = "";
            cell.style.gridRow = "";
            cell.style.gridColumn = "";
            cell.style.display = "flex";
            if (editable) {
                editable.style.fontSize = "";
                editable.style.alignItems = "";
                editable.style.justifyContent = "";
                editable.style.textAlign = "";
            }
        });
        document.getElementById("pageTitle").value = "Brain Hacker Home";
        undoHistory.length = 0; // Clear undo history
        saveState(); // Save initial blank state
        console.log("Grid reset.");
    }
});

document.getElementById("deleteBtn").addEventListener("click", () => {
  if (selectedCells.length === 0) {
    alert("ÂâäÈô§„Åô„Çã„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    return;
  }
  if (confirm("ÈÅ∏Êäû„Åó„Åü„Çª„É´„ÅÆÂÜÖÂÆπ„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü")) {
    selectedCells.forEach(cell => {
      const editable = cell.querySelector(".editable");
      const img = cell.querySelector("img");
      if (editable) editable.innerHTML = "";
      if (img) {
        img.src = "";
        img.style.display = "none";
      }
      cell.style.backgroundColor = "";
      
      // ÁµêÂêà„Åï„Çå„Åü„Çª„É´„Å†„Å£„ÅüÂ†¥Âêà„ÅÆÂá¶ÁêÜ
      const rowSpan = parseInt(cell.style.gridRow.replace("span ", "") || "1");
      const colSpan = parseInt(cell.style.gridColumn.replace("span ", "") || "1");
      
      if (rowSpan > 1 || colSpan > 1) {
        // ÁµêÂêà„Åï„Çå„Åü„Çª„É´„ÅÆÂ†¥Âêà„ÄÅÈñ¢ÈÄ£„Åô„ÇãÈö†„Çå„Åü„Çª„É´„ÇíË°®Á§∫„Å´Êàª„Åô
        const startRow = parseInt(cell.dataset.row);
        const startCol = parseInt(cell.dataset.col);
        
        for (let r = startRow; r < startRow + rowSpan; r++) {
          for (let c = startCol; c < startCol + colSpan; c++) {
            const relatedCell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
            if (relatedCell && relatedCell !== cell) {
              relatedCell.style.display = "flex";
            }
          }
        }
      }
      
      // „Çª„É´„ÅÆÁµêÂêà„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
      cell.style.gridRow = "";
      cell.style.gridColumn = "";
      cell.style.display = "flex";
    });
    clearSelections();
    autoSave();
  }
});


document.getElementById("alignTopLeftBtn").addEventListener("click", () => {
  if (selectedCells.length === 0) {
    alert("„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    return;
  }
  selectedCells.forEach(cell => {
    const editable = cell.querySelector(".editable");
    if (editable) {
      editable.style.alignItems = "flex-start";
      editable.style.justifyContent = "flex-start";
      editable.style.textAlign = "left";
    }
  });
  autoSave();
});

document.getElementById("alignCenterBtn").addEventListener("click", () => {
  if (selectedCells.length === 0) {
    alert("„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    return;
  }
  selectedCells.forEach(cell => {
    const editable = cell.querySelector(".editable");
    if (editable) {
      editable.style.alignItems = "center";
      editable.style.justifyContent = "center";
      editable.style.textAlign = "center";
    }
  });
  autoSave();
});


// === ÂàùÊúü„É≠„Éº„Éâ ===
document.addEventListener("DOMContentLoaded", () => {
  restoreState(); // Load today's or yesterday's state
  // Initial save of the restored state to history
  if (undoHistory.length === 0) {
      const initialCompressed = localStorage.getItem(`brainhack-${getTodayKey()}`);
      if (initialCompressed) {
          try {
              const initialState = JSON.parse(decodeURIComponent(atob(initialCompressed)));
              undoHistory.push(JSON.parse(JSON.stringify(initialState)));
          } catch (e) {
              console.error("Error parsing initial state for history:", e);
          }
      }
  }
});

  </script>
</body>
</html>