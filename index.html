<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brain Hacker</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #f0f2f5;
      color: #333;
      overflow-x: hidden; /* Prevent horizontal scroll */
    }
    .header {
      background-color: #4285f4;
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .header h1 {
      margin: 0;
      font-size: 1.8em;
    }
    .buttons {
      display: flex;
      gap: 10px;
    }
    .btn {
      background-color: #6c757d;
      color: white;
      padding: 8px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background-color 0.3s ease;
    }
    .btn:hover {
      background-color: #5a6268;
    }
    .btn-primary {
      background-color: #28a745; /* Green for main action */
    }
    .btn-primary:hover {
      background-color: #218838;
    }
    .btn-danger {
      background-color: #dc3545; /* Red for reset */
    }
    .btn-danger:hover {
      background-color: #c82333;
    }
    .btn-info {
        background-color: #17a2b8; /* Blue for info */
    }
    .btn-info:hover {
        background-color: #138496;
    }

    .grid-container {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(16, 1fr);
      width: 100%;
      max-width: 1200px; /* Adjust as needed */
      height: calc(100vh - 80px); /* Full viewport height minus header */
      min-height: 500px; /* Minimum height for smaller screens */
      margin: 20px auto;
      gap: 1px;
      background-color: #ddd;
      border: 1px solid #ccc;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      overflow: auto; /* Enable scrolling for grid itself */
    }

    .grid-cell {
      background-color: white;
      border: 1px solid #eee;
      display: flex;
      flex-direction: column;
      justify-content: flex-start; /* Align content to top */
      align-items: flex-start; /* Align content to left */
      padding: 5px;
      box-sizing: border-box;
      position: relative; /* For context menu positioning */
      overflow: hidden; /* Hide overflow for content editable */
      font-size: 0.8em; /* Adjust font size for better fit */
    }

    /* Content editable span inside the cell */
    .grid-cell > span {
      flex-grow: 1; /* Allow content to take available space */
      width: 100%; /* Ensure content spans full width */
      outline: none; /* Remove focus outline */
      word-break: break-word; /* Break long words */
      white-space: pre-wrap; /* Preserve whitespace and wrap */
      overflow: auto; /* Allow scrolling within span if content is too large */
      max-height: 100%; /* Limit height to cell height */
    }

    .grid-cell.highlighted {
      outline: 2px solid #4285f4; /* Highlight selected cells */
      outline-offset: -2px;
    }

    .grid-cell.merged {
      display: flex;
      /* grid-row and grid-column will be set dynamically */
    }

    /* Hidden cells for merged areas */
    .grid-cell.hidden {
      display: none;
    }

    /* Checkbox and text styling */
    .grid-cell input[type="checkbox"] {
      margin-right: 5px;
      flex-shrink: 0; /* Prevent checkbox from shrinking */
      align-self: center; /* Center checkbox vertically if text is multi-line */
    }
    .grid-cell span[contenteditable="true"] {
        flex-grow: 1; /* Allow text to take available space */
        min-width: 0; /* Allow text to shrink below its content size */
    }
    .grid-cell .completed-text {
      text-decoration: line-through;
      color: #888;
    }
    .grid-cell b {
        font-weight: bold; /* Ensure bold is applied */
    }

    /* Context Menu */
    .context-menu {
      display: none;
      position: absolute;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      z-index: 100;
      min-width: 150px;
    }
    .context-menu ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .context-menu li {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.9em;
    }
    .context-menu li:hover {
      background-color: #f0f0f0;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
</head>
<body>
  <div class="header">
    <h1>Brain Hacker</h1>
    <div class="buttons">
      <button id="recordBtn" class="btn btn-info">Record</button>
      <button id="addCheckboxBtn" class="btn">Add Checkbox</button>
      <button id="addNoteBtn" class="btn">Add Note</button>
      <button id="mergeCellsBtn" class="btn btn-primary">Merge Cells</button>
      <button id="splitCellsBtn" class="btn">Split Cells</button>
      <button id="resetGridBtn" class="btn btn-danger">Reset Grid</button>
      <button id="shareBtn" class="btn">Share</button>
    </div>
  </div>

  <div id="gridContainer" class="grid-container">
    </div>

  <div id="contextMenu" class="context-menu">
    <ul>
      <li data-action="add-checkbox">Add Checkbox</li>
      <li data-action="add-note">Add Note</li>
      <li data-action="merge-cells">Merge Cells</li>
      <li data-action="split-cells">Split Cells</li>
      <li data-action="bold-text">Bold Text</li>
      <li data-action="insert-br">Insert Line Break</li>
      <li data-action="clear-cell">Clear Cell</li>
    </ul>
  </div>

  <script>
    const gridContainer = document.getElementById('gridContainer');
    const addCheckboxBtn = document.getElementById('addCheckboxBtn');
    const addNoteBtn = document.getElementById('addNoteBtn');
    const mergeCellsBtn = document.getElementById('mergeCellsBtn');
    const splitCellsBtn = document.getElementById('splitCellsBtn');
    const resetGridBtn = document.getElementById('resetGridBtn');
    const recordBtn = document.getElementById('recordBtn');
    const shareBtn = document.getElementById('shareBtn');
    const contextMenu = document.getElementById('contextMenu');

    const ROWS = 16;
    const COLS = 20;
    let selectedCells = [];
    let currentCellData = []; // To store content and merged state

    // --- Utility Functions ---
    function getTodayKey() {
      const now = new Date();
      return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    }

    let saveTimeout;
    function autoSave() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveGridState();
        console.log("Grid state automatically saved.");
      }, 1000); // 1秒後に保存
    }

    function saveGridState() {
      const state = {
        d: getTodayKey(), // Date key
        cells: []
      };
      document.querySelectorAll('.grid-cell:not(.hidden)').forEach(cell => {
        const r = parseInt(cell.dataset.row);
        const c = parseInt(cell.dataset.col);
        const gridRow = cell.style.gridRow;
        const gridColumn = cell.style.gridColumn;

        // Clone the cell content to clean up temporary attributes before saving
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cell.innerHTML;
        tempDiv.querySelectorAll('span[contenteditable="true"]').forEach(span => {
            // Remove the contenteditable attribute for saving, as it's not needed for display
            // and might interfere with parsing on other pages if not handled correctly.
            // It will be re-added when the cell is created/rendered.
            span.removeAttribute('contenteditable');
        });
        tempDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            // Only add 'checked' attribute if the checkbox is actually checked
            if (checkbox.checked) {
                checkbox.setAttribute('checked', 'true');
            } else {
                checkbox.removeAttribute('checked');
            }
        });
        // Remove 'completed-text' class for saving, will be re-applied on load
        tempDiv.querySelectorAll('.completed-text').forEach(span => {
            span.classList.remove('completed-text');
            span.style.textDecoration = ''; // Remove inline style as well
            span.style.color = ''; // Remove inline color as well
        });


        state.cells.push({
          r: r,
          c: c,
          h: tempDiv.innerHTML, // Inner HTML of the cell content
          gr: gridRow, // grid-row style for merged cells
          gc: gridColumn // grid-column style for merged cells
        });
      });
      const compressed = LZString.compressToEncodedURIComponent(JSON.stringify(state));
      localStorage.setItem(`brainhack-${getTodayKey()}`, compressed);
    }


    function loadGridState() {
      const compressed = localStorage.getItem(`brainhack-${getTodayKey()}`);
      if (compressed) {
        try {
          const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
          const state = JSON.parse(decompressed);
          currentCellData = state.cells; // Load saved data
          renderGrid(); // Re-render the grid with loaded data
          console.log("Grid state loaded.");
          return true;
        } catch (e) {
          console.error("Failed to load grid state from localStorage:", e);
          return false;
        }
      }
      return false;
    }

    function renderGrid() {
      gridContainer.innerHTML = ''; // Clear existing grid
      const gridCells = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));

      // Populate a temporary grid with loaded data to handle merged cells
      currentCellData.forEach(cellData => {
        const r = parseInt(cellData.r);
        const c = parseInt(cellData.c);
        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
          gridCells[r][c] = {
            html: cellData.h,
            gridRow: cellData.gr,
            gridColumn: cellData.gc,
            isMergedBase: true
          };
          // Mark cells covered by a merged cell as hidden
          if (cellData.gr && cellData.gc) {
            const rowSpanMatch = cellData.gr.match(/span (\d+)/);
            const colSpanMatch = cellData.gc.match(/span (\d+)/);
            const rowSpan = rowSpanMatch ? parseInt(rowSpanMatch[1]) : 1;
            const colSpan = colSpanMatch ? parseInt(colSpanMatch[1]) : 1;

            for (let i = r; i < r + rowSpan; i++) {
              for (let j = c; j < c + colSpan; j++) {
                if (i === r && j === c) continue; // Skip the base cell itself
                if (i >= 0 && i < ROWS && j >= 0 && j < COLS) {
                  gridCells[i][j] = { isHidden: true };
                }
              }
            }
          }
        }
      });

      // Render cells to DOM
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          cell.classList.add('grid-cell');
          cell.dataset.row = r;
          cell.dataset.col = c;

          const cellInfo = gridCells[r][c];

          if (cellInfo && cellInfo.isHidden) {
            cell.classList.add('hidden');
          } else if (cellInfo && cellInfo.isMergedBase) {
            cell.style.gridRow = cellInfo.gridRow;
            cell.style.gridColumn = cellInfo.gridColumn;
            cell.classList.add('merged');

            // Set innerHTML and re-add contenteditable, and event listeners
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cellInfo.html || '';

            // Handle contenteditable for spans
            tempDiv.querySelectorAll('span').forEach(span => {
                if (!span.querySelector('input[type="checkbox"]')) { // Checkboxes handle their own content
                    span.setAttribute('contenteditable', 'true');
                }
            });
            // Handle checkbox state and styling
            tempDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.disabled = false; // Ensure it's not disabled
                if (checkbox.hasAttribute('checked')) {
                    checkbox.checked = true;
                    checkbox.nextElementSibling.classList.add('completed-text');
                } else {
                    checkbox.checked = false;
                    checkbox.nextElementSibling.classList.remove('completed-text');
                }
                checkbox.addEventListener('change', autoSave); // Auto-save on checkbox change
            });

            cell.appendChild(tempDiv);
          } else {
            // Default empty cell
            const span = document.createElement('span');
            span.setAttribute('contenteditable', 'true');
            span.innerHTML = '';
            cell.appendChild(span);
          }
          gridContainer.appendChild(cell);
        }
      }
      addCellEventListeners(); // Add event listeners to all cells
    }

    // --- Cell Interaction ---
    function addCellEventListeners() {
      document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.removeEventListener('click', selectCell); // Prevent duplicate listeners
        cell.addEventListener('click', selectCell);
        cell.removeEventListener('input', autoSave); // Auto-save on input
        cell.addEventListener('input', autoSave);
        cell.removeEventListener('contextmenu', showContextMenu); // Right-click for context menu
        cell.addEventListener('contextmenu', showContextMenu);
      });
    }

    function selectCell(event) {
      if (event.target.type === 'checkbox') return; // Don't select cell if checkbox is clicked

      const cell = event.currentTarget;
      const isSelected = cell.classList.contains('highlighted');

      // If Ctrl/Cmd is pressed, toggle selection for multiple cells
      if (event.ctrlKey || event.metaKey) {
        if (isSelected) {
          cell.classList.remove('highlighted');
          selectedCells = selectedCells.filter(c => c !== cell);
        } else {
          cell.classList.add('highlighted');
          selectedCells.push(cell);
        }
      } else {
        // Otherwise, clear previous selection and select only this cell
        clearSelection();
        cell.classList.add('highlighted');
        selectedCells = [cell];
      }
      updateButtonStates();
    }

    function clearSelection() {
      selectedCells.forEach(cell => cell.classList.remove('highlighted'));
      selectedCells = [];
      updateButtonStates();
    }

    function updateButtonStates() {
      const isSingleCellSelected = selectedCells.length === 1;
      const isMultipleCellsSelected = selectedCells.length > 1;

      addCheckboxBtn.disabled = !isSingleCellSelected;
      addNoteBtn.disabled = !isSingleCellSelected;
      mergeCellsBtn.disabled = !isMultipleCellsSelected || !canMergeCells(selectedCells);
      splitCellsBtn.disabled = !isSingleCellSelected || !selectedCells[0].classList.contains('merged');
    }

    function canMergeCells(cells) {
        if (cells.length < 2) return false;

        // Get min/max row/col for selected cells
        let minR = ROWS, maxR = -1, minC = COLS, maxC = -1;
        cells.forEach(cell => {
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);
            minR = Math.min(minR, r);
            maxR = Math.max(maxR, r);
            minC = Math.min(minC, c);
            maxC = Math.max(maxC, c);
        });

        // Check if all cells within the bounding box are selected
        for (let r = minR; r <= maxR; r++) {
            for (let c = minC; c <= maxC; c++) {
                const cell = document.querySelector(`.grid-cell[data-row='${r}'][data-col='${c}']`);
                if (!cell || !cell.classList.contains('highlighted')) {
                    return false; // Not all cells in rectangle selected
                }
                if (cell.classList.contains('hidden')) {
                    // If a "hidden" cell (part of a previously merged cell) is selected,
                    // it indicates an invalid selection for a new merge.
                    // This scenario is complex as it means user selected part of an existing merge.
                    // For simplicity, disallow merging if any part of an already hidden cell is selected.
                    return false;
                }
                if (cell.classList.contains('merged') && !cell.classList.contains('highlighted')) {
                    // A cell that is the base of a merged cell, but not highlighted, suggests invalid merge
                    return false;
                }
            }
        }
        return true;
    }


    // --- Context Menu Functions ---
    let rightClickedCell = null;

    function showContextMenu(event) {
        event.preventDefault(); // Prevent default right-click menu
        rightClickedCell = event.currentTarget; // Store the cell that was right-clicked

        // Clear existing selection and select only the right-clicked cell
        clearSelection();
        rightClickedCell.classList.add('highlighted');
        selectedCells = [rightClickedCell];
        updateButtonStates(); // Update button states based on this single selection

        // Position context menu
        contextMenu.style.left = `${event.clientX}px`;
        contextMenu.style.top = `${event.clientY}px`;
        contextMenu.style.display = 'block';
    }

    // Hide context menu when clicking anywhere else
    document.addEventListener('click', (event) => {
        if (!contextMenu.contains(event.target)) {
            contextMenu.style.display = 'none';
            // clearSelection(); // Optionally clear selection when menu closes
        }
    });

    // Handle context menu actions
    contextMenu.addEventListener('click', (event) => {
        const action = event.target.dataset.action;
        if (!action) return;

        contextMenu.style.display = 'none'; // Hide menu after action

        if (rightClickedCell) {
            switch (action) {
                case 'add-checkbox':
                    addCheckbox(rightClickedCell);
                    break;
                case 'add-note':
                    addNote(rightClickedCell);
                    break;
                case 'merge-cells':
                    // Merge action should ideally work on selectedCells, not just rightClickedCell
                    // Ensure mergeCellsBtn logic aligns with context menu behavior
                    mergeCells();
                    break;
                case 'split-cells':
                    splitCells();
                    break;
                case 'bold-text':
                    toggleBold(rightClickedCell);
                    break;
                case 'insert-br':
                    insertLineBreak(rightClickedCell);
                    break;
                case 'clear-cell':
                    clearCell(rightClickedCell);
                    break;
            }
        }
        clearSelection(); // Clear selection after action
        autoSave(); // Auto-save after context menu action
    });


    // --- Button Actions ---
    function addCheckbox(cell = selectedCells[0]) {
      if (!cell) return;
      // Ensure contenteditable span exists or create one
      let span = cell.querySelector('span[contenteditable="true"]');
      if (!span) {
        span = document.createElement('span');
        span.setAttribute('contenteditable', 'true');
        cell.innerHTML = ''; // Clear cell if no span existed
        cell.appendChild(span);
      }
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.addEventListener('change', function() {
        if (this.checked) {
          this.nextElementSibling.classList.add('completed-text');
        } else {
          this.nextElementSibling.classList.remove('completed-text');
        }
        autoSave(); // Auto-save on checkbox change
      });

      const textNode = document.createElement('span');
      textNode.setAttribute('contenteditable', 'true'); // Text part is also editable
      textNode.innerHTML = 'New Task'; // Default text

      const wrapper = document.createElement('span'); // Wrapper for checkbox and text
      wrapper.appendChild(checkbox);
      wrapper.appendChild(textNode);

      // Append at caret position if possible, otherwise at the end
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          range.deleteContents(); // Delete any selected content
          range.insertNode(wrapper);
          range.setStartAfter(wrapper);
          range.setEndAfter(wrapper);
          selection.removeAllRanges();
          selection.addRange(range);
      } else {
          span.appendChild(wrapper);
      }
      autoSave(); // Auto-save after adding checkbox
    }

    function addNote(cell = selectedCells[0]) {
        if (!cell) return;
        // Ensure contenteditable span exists or create one
        let span = cell.querySelector('span[contenteditable="true"]');
        if (!span) {
            span = document.createElement('span');
            span.setAttribute('contenteditable', 'true');
            cell.innerHTML = ''; // Clear cell if no span existed
            cell.appendChild(span);
        }

        const noteDiv = document.createElement('div');
        const boldText = document.createElement('b');
        boldText.textContent = 'Note: ';
        noteDiv.appendChild(boldText);
        const noteTextSpan = document.createElement('span');
        noteTextSpan.setAttribute('contenteditable', 'true');
        noteTextSpan.innerHTML = ''; // Start with empty content
        noteDiv.appendChild(noteTextSpan);

        // Append at caret position if possible, otherwise at the end
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            range.deleteContents(); // Delete any selected content
            range.insertNode(noteDiv);
            range.setStartAfter(noteDiv);
            range.setEndAfter(noteDiv);
            selection.removeAllRanges();
            selection.addRange(range);
        } else {
            span.appendChild(noteDiv);
        }
        autoSave(); // Auto-save after adding note
    }

    function toggleBold(cell = selectedCells[0]) {
        if (!cell) return;
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const selectedText = range.toString();

            if (selectedText.length > 0) {
                const bold = document.createElement('b');
                bold.textContent = selectedText;
                range.deleteContents();
                range.insertNode(bold);
            } else {
                // If no text selected, find the current node and toggle bold
                const currentNode = selection.focusNode.parentNode;
                if (currentNode && currentNode.tagName === 'B') {
                    // Remove bold
                    const textNode = document.createTextNode(currentNode.textContent);
                    currentNode.parentNode.replaceChild(textNode, currentNode);
                } else if (currentNode && currentNode.getAttribute('contenteditable') === 'true') {
                    // Add bold to next typed text
                    document.execCommand('bold', false, null);
                }
            }
        }
        autoSave(); // Auto-save after toggling bold
    }

    function insertLineBreak(cell = selectedCells[0]) {
        if (!cell) return;
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const br = document.createElement('br');
            range.insertNode(br);
            range.setStartAfter(br);
            range.setEndAfter(br);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        autoSave(); // Auto-save after inserting line break
    }

    function clearCell(cell = selectedCells[0]) {
        if (cell) {
            const contenteditableSpan = cell.querySelector('span[contenteditable="true"]');
            if (contenteditableSpan) {
                contenteditableSpan.innerHTML = '';
            } else {
                cell.innerHTML = ''; // Clear everything if no span
            }
            autoSave(); // Auto-save after clearing cell
        }
    }


    function mergeCells() {
      if (selectedCells.length < 2 || !canMergeCells(selectedCells)) {
        alert("有効なセル範囲を選択してください。");
        return;
      }

      // Determine the bounding box of selected cells
      let minR = ROWS, maxR = -1, minC = COLS, maxC = -1;
      selectedCells.forEach(cell => {
        const r = parseInt(cell.dataset.row);
        const c = parseInt(cell.dataset.col);
        minR = Math.min(minR, r);
        maxR = Math.max(maxR, r);
        minC = Math.min(minC, c);
        maxC = Math.max(maxC, c);
      });

      const baseCell = document.querySelector(`.grid-cell[data-row='${minR}'][data-col='${minC}']`);
      if (!baseCell) return;

      // Calculate span values
      const rowSpan = maxR - minR + 1;
      const colSpan = maxC - minC + 1;

      // Apply grid-row and grid-column to the base cell
      baseCell.style.gridRow = `${minR + 1} / span ${rowSpan}`;
      baseCell.style.gridColumn = `${minC + 1} / span ${colSpan}`;
      baseCell.classList.add('merged'); // Add merged class

      // Move content from other selected cells to the base cell
      const baseCellContentSpan = baseCell.querySelector('span[contenteditable="true"]');
      if (baseCellContentSpan) {
        selectedCells.forEach(cell => {
          if (cell !== baseCell) {
            const content = cell.querySelector('span[contenteditable="true"]');
            if (content && content.innerHTML.trim() !== '') {
              // Add a line break before appending content from other cells
              if (baseCellContentSpan.innerHTML.trim() !== '') {
                baseCellContentSpan.appendChild(document.createElement('br'));
              }
              baseCellContentSpan.innerHTML += content.innerHTML;
            }
          }
        });
      }

      // Hide other selected cells
      selectedCells.forEach(cell => {
        if (cell !== baseCell) {
          cell.classList.add('hidden');
          // Clear its content to prevent duplication if split later
          cell.innerHTML = '';
          cell.style.gridRow = ''; // Remove grid styles
          cell.style.gridColumn = '';
          cell.classList.remove('merged');
        }
      });
      clearSelection();
      autoSave(); // Auto-save after merging
    }

    function splitCells() {
      if (selectedCells.length !== 1) {
        alert("分割するには単一の結合されたセルを選択してください。");
        return;
      }
      const cell = selectedCells[0];
      if (!cell.classList.contains('merged')) {
        alert("選択されたセルは結合されていません。");
        return;
      }

      const r = parseInt(cell.dataset.row);
      const c = parseInt(cell.dataset.col);

      // Get current span values
      const rowSpanMatch = cell.style.gridRow.match(/span (\d+)/);
      const colSpanMatch = cell.style.gridColumn.match(/span (\d+)/);
      const rowSpan = rowSpanMatch ? parseInt(rowSpanMatch[1]) : 1;
      const colSpan = colSpanMatch ? parseInt(colSpanMatch[1]) : 1;

      // Reset base cell styles
      cell.style.gridRow = '';
      cell.style.gridColumn = '';
      cell.classList.remove('merged');

      // Unhide and reset other cells in the original merged area
      for (let i = r; i < r + rowSpan; i++) {
        for (let j = c; j < c + colSpan; j++) {
          if (i === r && j === c) continue; // Skip the base cell itself
          const hiddenCell = document.querySelector(`.grid-cell[data-row='${i}'][data-col='${j}']`);
          if (hiddenCell) {
            hiddenCell.classList.remove('hidden');
            // Re-add default contenteditable span for split cells
            const span = document.createElement('span');
            span.setAttribute('contenteditable', 'true');
            span.innerHTML = '';
            hiddenCell.innerHTML = ''; // Clear any residual content
            hiddenCell.appendChild(span);
          }
        }
      }
      clearSelection();
      autoSave(); // Auto-save after splitting
    }

    function resetGrid() {
      if (confirm("本当に全てのグリッドをリセットしますか？この操作は元に戻せません。")) {
        localStorage.removeItem(`brainhack-${getTodayKey()}`); // Clear data for today
        currentCellData = []; // Clear in-memory data
        renderGrid(); // Render a fresh empty grid
        console.log("Grid reset and local storage cleared for today.");
      }
    }

    function shareGrid() {
        const state = {
            d: getTodayKey(), // Date key
            cells: []
        };
        // Retrieve data from localStorage for the current day
        const compressed = localStorage.getItem(`brainhack-${getTodayKey()}`);
        if (compressed) {
            try {
                const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
                const parsedData = JSON.parse(decompressed);
                state.cells = parsedData.cells; // Use the already saved and compressed data
            } catch (e) {
                console.error("Error parsing data for sharing:", e);
                alert("共有データを作成できませんでした。");
                return;
            }
        } else {
            alert("共有するデータがありません。");
            return;
        }

        const compressedShareData = LZString.compressToEncodedURIComponent(JSON.stringify(state));
        const shareURL = `${window.location.origin}/Brainhacker2.0/record.html?data=${compressedShareData}`; // Adjust path if necessary

        navigator.clipboard.writeText(shareURL)
            .then(() => {
                alert("共有リンクがクリップボードにコピーされました！\n\n" + shareURL);
            })
            .catch(err => {
                console.error('リンクのコピーに失敗しました', err);
                alert("リンクのコピーに失敗しました。手動でコピーしてください:\n\n" + shareURL);
            });
    }


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
      if (!loadGridState()) { // Try to load saved state
        renderGrid(); // If no saved state, render empty grid
      }
      updateButtonStates(); // Set initial button states

      // Add event listeners for buttons
      addCheckboxBtn.addEventListener('click', () => { addCheckbox(); autoSave(); });
      addNoteBtn.addEventListener('click', () => { addNote(); autoSave(); });
      mergeCellsBtn.addEventListener('click', () => { mergeCells(); autoSave(); });
      splitCellsBtn.addEventListener('click', () => { splitCells(); autoSave(); });
      resetGridBtn.addEventListener('click', resetGrid);
      shareBtn.addEventListener('click', shareGrid);

      // Record button to navigate to record.html
      recordBtn.addEventListener('click', () => {
        window.location.href = 'record.html';
      });

      // Hide context menu when right-clicking on elements outside any grid cell
      document.addEventListener('contextmenu', (event) => {
          if (!event.target.closest('.grid-cell') && !contextMenu.contains(event.target)) {
              event.preventDefault(); // Prevent default context menu
              contextMenu.style.display = 'none';
          }
      });
    });

  </script>
</body>
</html>